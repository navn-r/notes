<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on &lt;✏️ /></title><link>https://navn-r.github.io/notes/</link><description>Recent content in Home on &lt;✏️ /></description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 09 Aug 2020 23:28:18 +0000</lastBuildDate><atom:link href="https://navn-r.github.io/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Week 1</title><link>https://navn-r.github.io/notes/CSCB09/Week-1/</link><pubDate>Wed, 20 May 2020 14:33:50 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-1/</guid><description>Week 1 # Processes # What happens when you run a program.
Has Input and Output ends:
stdin: Standard Input - eg. Keyboard input goes through stdin stdout: Standard Output - eg. Terminal output (printing to screen) eg.
Navinns-MacBook-Pro:~ home$ sort # OS connects keyboard to stdin Watermelon Apple Strawberry Mango ^D # &amp;#39;exit&amp;#39; keybind, OS connects screen to stdout Apple Mango Strawberry Watermelon Pipelining and Redirection # Routing outputs of one program to the input of another, and outputting to a file instead of the screen.</description></item><item><title>Week 1</title><link>https://navn-r.github.io/notes/CSCC24/Week-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-1/</guid><description>Week 1 # Translation # The process of converting high-level source code into machine code.
A Programming Language (PL) is neither compiled or interpreted, it&amp;rsquo;s implementation can be.
Types of Translation # Compilation: translated before execution
[Source Code] -&amp;gt; {Compiler} -&amp;gt; (Target Code) Target code optimises for speed and security verification (potential memory leaks) for the specific machine
&amp;lsquo;Heavy&amp;rsquo; information (i.</description></item><item><title>Week 2</title><link>https://navn-r.github.io/notes/CSCB09/Week-2/</link><pubDate>Tue, 26 May 2020 17:52:24 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-2/</guid><description>Week 2 # File Management # How we survived without File Explorer
Directory Tree # / ├── Applications ├── Library ├── System ├── *Users* ├── Volumes ├── bin ├── cores ├── *dev* ├── etc -&amp;gt; private/etc ├── *home* -&amp;gt; /System/Volumes/Data/home ├── opt ├── private ├── sbin ├── tmp -&amp;gt; private/tmp ├── *usr* └── var -&amp;gt; private/var Paths # Absolute Path: from root dir</description></item><item><title>Week 3</title><link>https://navn-r.github.io/notes/CSCB09/Week-3/</link><pubDate>Tue, 02 Jun 2020 17:42:22 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-3/</guid><description>Week 3 # Introduction to Shell # More features available from man sh
Simple Commands # 4 general cases of commands
Built in commands: cd, ls etc. User defined functions Aliases eg. alias pls=&amp;quot;sudo&amp;quot; Commands that refer to the program name eg. tr command runs the tr program Sequential List # Multi-line commands in a single line
$ cd projects ; sort file1 | uniq # runs cd then runs sort with pipe # equivalent to $ cd projects projects$ sort file1 | uniq Grouping: Explicit: {grep foo file1 ; ls ; } &amp;gt; file2 Exit Codes # 0 for success, non-0 for failure</description></item><item><title>Week 4</title><link>https://navn-r.github.io/notes/CSCB09/Week-4/</link><pubDate>Tue, 02 Jun 2020 19:14:38 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-4/</guid><description>Week 4 # Shell Scripting # Running Scripts # $ sh myscript Alternatively, in your myscript.sh file, do the following
#! /bin/sh chmod u+x myscript # sets &amp;#39;executable&amp;#39; flag on the file and run it with&amp;hellip;
$ ./myscript Positional Parameters # $ ./myscript foo bar baz # come after filename, spaced $#: Number of arguments (3) $n: Parameter name (n is the number) eg. $1 = &amp;quot;foo&amp;quot; $*: One string with all parameter names &amp;quot;foo bar baz&amp;quot; $@: Comma seperated strings for each parameter name &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; shift: Shifts Positional Parameters by 1 $# = 2 $1 = &amp;#34;bar&amp;#34; $2 = &amp;#34;baz&amp;#34; $* = &amp;#34;bar baz&amp;#34; # good for looping over parameters Example Script # #!</description></item><item><title>Week 5</title><link>https://navn-r.github.io/notes/CSCB09/Week-5/</link><pubDate>Wed, 10 Jun 2020 17:30:31 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-5/</guid><description>Week 5 # Programming in C # Memory Model # Array of bytes, &amp;ldquo;Addresses&amp;rdquo; are indexes Variables may occupy several consecutive bytes, its address refers to the first occupied byte &amp;ldquo;Pointer&amp;rdquo;: Variable/parameter that stores an address int i = 69; // Suppose i was occupying bytes 45 to 74 int *p = &amp;amp;i // 45 Memory Regions # Text: Stores code Pointers pointing to functions point here Global: Stores global variables Stack: Used for function calls Stores local variables Auto allocation and deallocation Heap: Manual allocation (malloc(), calloc()) and deallocation (free()) Used for dynamic data outside of functions Global Variables # Two types of varaibles int pubVar = 10; // top-level public global variable int f() { static int privVar = 1010; // function private global variable pubVar++; privVar++; .</description></item><item><title>Week 6</title><link>https://navn-r.github.io/notes/CSCB09/Week-6/</link><pubDate>Wed, 17 Jun 2020 00:06:17 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-6/</guid><description>Week 6 # Programming in C (cont.) # File I/O in C # Content can be accessed as a steam (seq. read/write) File functions work with FILE * FILE: Type rep. stream state, definition varies by platform, most likely a struct Open # FILE *fopen(const char *filename, const char *mode) Modes: &amp;quot;r&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;r+&amp;quot;, &amp;quot;w+&amp;quot;, &amp;quot;a+&amp;quot; Read, Write, Append, Read &amp;amp; Write, Write &amp;amp; Read, Append &amp;amp; Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL) Close # int fclose(FILE *stream) Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as you&amp;rsquo;re finished: There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only) Formatted I/O # // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, .</description></item><item><title>Week 7</title><link>https://navn-r.github.io/notes/CSCB09/Week-7/</link><pubDate>Wed, 08 Jul 2020 17:41:52 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-7/</guid><description>Week 7 # Programming in C (cont.) # Compiler and Linker Stages # myProgram.c $\to$ Compiler $\to$ Machine Code (myProgram.o) $\to$ Libraries + Linker $\to$ Executable
myProgram.o is the object code file Libraries: where methods from stdio.h/stdlib.h come from Linker: Merges object files and libraries into one executable gcc serves as a convenient linker frontend C Compiler Stages # The C compiler futher breaks down into:</description></item><item><title>Week 8</title><link>https://navn-r.github.io/notes/CSCB09/Week-8/</link><pubDate>Sat, 18 Jul 2020 20:09:18 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-8/</guid><description>Week 8 # File System with C # i-nodes # The file system has an array of &amp;lsquo;i-nodes&amp;rsquo;
Every file and directory is identified using an i-node
An i-node stores:
Type: Regular file, dir, link, device, socket, etc. Permissions The owning user and owning group (numerical ids) Size Timestamps (created, last modified) Which disk blocks are used Other metadata You can get most metadata by using the stat command</description></item><item><title>Week 9</title><link>https://navn-r.github.io/notes/CSCB09/Week-9/</link><pubDate>Sat, 25 Jul 2020 20:45:11 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-9/</guid><description>Week 9 # Processes and Redirection # Launching a New Process # Clone the process pid_t fork(void); // child gets return value 0, parent gets child&amp;#39;s pid Both processes (child and parent) run the same code The child can switch to running another program execlp(path, arg0, arg1, ..., (char *)NULL); // &amp;#39;exec&amp;#39; family of system calls Things such as environment variables, pid, fd, current dir, etc.</description></item><item><title>Week 10</title><link>https://navn-r.github.io/notes/CSCB09/Week-10/</link><pubDate>Mon, 03 Aug 2020 18:51:53 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-10/</guid><description>Week 10 # Sockets # Another way for two processes to communicate
Characteristics of Sockets # Has 2 sides: Server and Client Server: has a publishable address Client: contacts Server by published address Unrelated processes, even on different computers, can contact each other through sockets Socket Varieties # By Domain # Unix Domain: Local to the computer, address is a filename IPv4: Over the network, 32-bit address + 16-bit port number IPv6: 128-bit address and over the network By Abstraction Level # Datagram: Per packet Packet boundary preserved, packet order is not Unnoticed packet loss Stream: Network stack works hard to confirm, timeout, resend Preserves data order No packet boundary Stream Socket Workflow # Client # Call socket, creates the socket fd Fill in the address struct and use connect to connect to the server at the address Use the socket fd to communicate with the server Close the fd when done Server # Call socket to create the server socket fd Fill in the address struct and use bind to bind the sfd to the address Call listen Loop Call accept(sfd) to wait for client to connect, gets back a client fd Use the cfd to communicate with client, close when done Close the server socket fd if no longer waiting for clients Creating Sockets # int socket(int family, int type, int protocol); // returns socket fd &amp;gt; 0, -1 if error family: AF_UNIX, AF_INET (IPv4), AF_INET6 (IPv6) type: SOCK_DGRAM, SOCK_STREAM protocol: 0 IPv4 Addresses and Port struct # Adresses are 32-bit, and identifies network interfaces (computers) Each byte is seperated by dots.</description></item><item><title>Week 11</title><link>https://navn-r.github.io/notes/CSCB09/Week-11/</link><pubDate>Sun, 09 Aug 2020 23:28:18 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-11/</guid><description>Week 11 # Multiplexing Input and Output # Handling multiple input/output clients with select and epoll
select # int select(int n, fd_set *read_fds, fd_set *write_fds, NULL, struct timeval *wait_timeout); Blocks until fds are ready Returns 0 if reaches the timeout, else returns positive count if some fds are ready Modifies the given fd_sets, set them again before the next call fd_set: holds a set of file descriptors n: The highest fd you specify, + 1 fd_set functions # void FD_ZERO(fd_set *s); // empties the set void FD_SET(int fd, fd_set *s); // adds an fd to the set void FD_CLR(int fd, fd_set *s); // deletes an fd int FD_ISSET(int fd, fd_set *s); // queries if fd is in the set Limitations # Max size for fd_set usually 1024 Slow when using many file descriptors epoll # Only available on Linux</description></item><item><title/><link>https://navn-r.github.io/notes/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/README/</guid><description>Notes #
Typed notes for my undergraduate classes at the University of Toronto, Canada.
Course Notes thus far:
CSCA48H3: Intro to Computer Science II CSCB09H3: Software Tools and Systems Programming CSCC01H3: Intro to Software Engineering src branch:
Folders containing the actual notes, typed with Markdown starter.tex: Starter File used for LaTeX notes/assignments master branch:
Static site generated with Hugo with book theme Automated build from src and deployment using TravisCI and Github Pages Made with ❤️ by Navinn Ravindaran</description></item><item><title>Final Review</title><link>https://navn-r.github.io/notes/CSCA48/final-review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCA48/final-review/</guid><description>CSCA48 - Final Review # Winter 2020 # If you think it won&amp;rsquo;t work in C, it probably will.
Units 1 + 2: # Variables and lockers: # Uniquely numbered in increasing order, reserved only for the program using the box to store and access information in said box.
Three ways to get a locker: # Variable Declaration int boostMyMark = 420; // locker has been created Return Values return boostMyMark; // new locker has been created, (copied value) Input Parameters void killAverage(double currentAvg, double midtermMark) {.</description></item><item><title>Final Review</title><link>https://navn-r.github.io/notes/CSCC01/final-review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC01/final-review/</guid><description>CSCC01 - Final Review # Fall 2020 # The fix from StackOverflow isn&amp;rsquo;t working
Software Development - The Agile Mindset # Iterative approach to software development
Values of the Agile Manifesto: # Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan User Stories # Short, simple descriptions for features as told by the end-user</description></item></channel></rss>