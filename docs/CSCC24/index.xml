<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSCC24 on &lt;✏️ /></title><link>https://navn-r.github.io/notes/CSCC24/</link><description>Recent content in CSCC24 on &lt;✏️ /></description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://navn-r.github.io/notes/CSCC24/index.xml" rel="self" type="application/rss+xml"/><item><title>Week 1</title><link>https://navn-r.github.io/notes/CSCC24/Week-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-1/</guid><description>Week 1 # Translation # The process of converting high-level source code into machine code.
A Programming Language (PL) is neither compiled or interpreted, it&amp;rsquo;s implementation can be.
Types of Translation # Compilation: translated before execution
[Source Code] -&amp;gt; {Compiler} -&amp;gt; (Target Code) Target code optimises for speed and security verification (potential memory leaks) for the specific machine
&amp;lsquo;Heavy&amp;rsquo; information (i.</description></item><item><title>Week 2</title><link>https://navn-r.github.io/notes/CSCC24/Week-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-2/</guid><description>Week 2 # Programming Languages define syntax formally.
Lexical Rules: specify the form of the &amp;lsquo;building blocks&amp;rsquo; of a PL
i.e. Comment Syntax, Tokens (keywords, literals, operators, etc.) and delimiters, White space Syntax: specifies how the &amp;lsquo;building blocks&amp;rsquo; are put together
Regular Expressions # Notation # Kleene Star (*): 0 or more repetitions
Alternation (+ or |): denotes choice</description></item><item><title>Week 3</title><link>https://navn-r.github.io/notes/CSCC24/Week-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-3/</guid><description>Week 3 # Higher-Order Procedures # Procedures as returned values.
All modern functional PLs manipulates functions as values.
; f, g are functions and (f (g)) is well-defined (define (compose f g) (lambda x (f (g x)))) ; returns the composed function map # Usage:
(map proc l1 l2 ... ln) proc: n-ary procedure (expects n arguments)
l1, ..., ln: lists of length m</description></item><item><title>Week 4</title><link>https://navn-r.github.io/notes/CSCC24/Week-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-4/</guid><description>Week 4 # Local Bindings # Creating variables with a local scope, and bind them to the result of expressions
Scope: Visibility of variables let # Usage:
(let ([var1 expr1] ... [varn exprn]) body) expr1, ..., exprn are evaluated in an undefined order, has the appearance of running in parallel
The scope of var1, ..., varn is body
Note: vari is not in the scope of [varj, exprj] when i !</description></item><item><title>Week 5</title><link>https://navn-r.github.io/notes/CSCC24/Week-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-5/</guid><description>Week 5 # Tail Recursion # Consider the following function
(define (len xs) (if (empty? xs) 0 (+ 1 (len (rest xs))))) ; trace (len &amp;#39;(1 2)) (+ 1 (len &amp;#39;(2))) (+ 1 (+ 1 (len &amp;#39;()))) (+ 1 (+ 1 0)) (+ 1 1) 2 The space complexity for this is precisely $O(n)$, where $n$ is the length of xs.
For a small enough stack space, and large enough list, this function can result in a Stack Overflow.</description></item><item><title>Week 6</title><link>https://navn-r.github.io/notes/CSCC24/Week-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-6/</guid><description>Week 6 # Pure Functional Languages # Programs: collections of functions Execution: view as evaluation Referential Transparency # The value of applying a function is independent of its context
Consider the program
# Top part of program f(a, b, c) # well-formed expression # Bottom part of program A program exhibits Referential Transparency, if it behaves the exact same, when the expression f(a, b, c) is replaced with its value.</description></item><item><title>Week 7</title><link>https://navn-r.github.io/notes/CSCC24/Week-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-7/</guid><description>Week 7 # Type Systems # Type: Name of a set of values and operations which can be performed on the set
Alternate: Collection of computational entities that share some common property What is or is not a type, is language dependent A PL is Type Safe if it won&amp;rsquo;t execute a function if it&amp;rsquo;s not applicable to the arguments
Type Checking:</description></item><item><title>Week 8</title><link>https://navn-r.github.io/notes/CSCC24/Week-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-8/</guid><description>Week 8 # Pattern Matching # Input parameters for a function are matched from top down
len :: [a] -&amp;gt; Integer len [] = 0 -- if the input is null, returns 0 len (_ : xs) = 1 + len xs The _ represents a &amp;lsquo;do not care&amp;rsquo; value, as its not bound to a variable
this.handle((_, event) =&amp;gt; ...); Value Matching in Haskell # reverse xs = rev xs [] where rev [] rs = rs rev (y : ys) rs = rev ys (y : rs) abs x = if x &amp;gt;= 0 then x else =x abs x | x &amp;gt;= 0 = x | otherwise = -x Type Classes # Offer a controlled approach to overloading</description></item><item><title>Week 9</title><link>https://navn-r.github.io/notes/CSCC24/Week-9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-9/</guid><description>Week 9 # Infix Operators # Any curried function that takes 2 parameters can be converted, and vice versa
x = 3 + 2 -- infix x = (+) 3 2 -- function y = elem 3 [1,2,3] y = 3 `elem` [1,2,3] -- infix Type Synonyms # Giving existing types an alias or new name
type NewType = OldType Useful for readability (String instead of [Char]) User Defined Data Types # General Syntax:</description></item><item><title>Week 10</title><link>https://navn-r.github.io/notes/CSCC24/Week-10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-10/</guid><description>Week 10 # Short Circuiting # Defined in most if not all programing languages
Consider the expression
if x &amp;gt; 0 and 69 / x &amp;lt; 1: print(&amp;#39;hoe&amp;#39;) If x happened to be 0, evaluating 69 / x only would result in a division by 0 error The second comparison would only be evaluated if the first was not false i.e. if x was non-positive, then the rest wouldn&amp;rsquo;t be evaluated, acts as a &amp;lsquo;guard&amp;rsquo; Laziness # Only evaluate things when you need to</description></item></channel></rss>