<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSCC24 on &lt;✏️ /></title><link>https://navn-r.github.io/notes/CSCC24/</link><description>Recent content in CSCC24 on &lt;✏️ /></description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://navn-r.github.io/notes/CSCC24/index.xml" rel="self" type="application/rss+xml"/><item><title>Week 1</title><link>https://navn-r.github.io/notes/CSCC24/Week-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-1/</guid><description>Week 1 # Translation # The process of converting high-level source code into machine code.
A Programming Language (PL) is neither compiled or interpreted, it&amp;rsquo;s implementation can be.
Types of Translation # Compilation: translated before execution
[Source Code] -&amp;gt; {Compiler} -&amp;gt; (Target Code) Target code optimises for speed and security verification (potential memory leaks) for the specific machine
&amp;lsquo;Heavy&amp;rsquo; information (i.</description></item><item><title>Week 2</title><link>https://navn-r.github.io/notes/CSCC24/Week-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-2/</guid><description>Week 2 # Programming Languages define syntax formally.
Lexical Rules: specify the form of the &amp;lsquo;building blocks&amp;rsquo; of a PL
i.e. Comment Syntax, Tokens (keywords, literals, operators, etc.) and delimiters, White space Syntax: specifies how the &amp;lsquo;building blocks&amp;rsquo; are put together
Regular Expressions # Notation # Kleene Star (*): 0 or more repetitions
Alternation (+ or |): denotes choice</description></item><item><title>Week 3</title><link>https://navn-r.github.io/notes/CSCC24/Week-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-3/</guid><description>Week 3 # Higher-Order Procedures # Procedures as returned values.
All modern functional PLs manipulates functions as values.
; f, g are functions and (f (g)) is well-defined (define (compose f g) (lambda x (f (g x)))) ; returns the composed function map # Usage:
(map proc l1 l2 ... ln) proc: n-ary procedure (expects n arguments)
l1, ..., ln: lists of length m</description></item><item><title>Week 4</title><link>https://navn-r.github.io/notes/CSCC24/Week-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCC24/Week-4/</guid><description>Week 4 # Local Bindings # Creating variables with a local scope, and bind them to the result of expressions
Scope: Visibility of variables let # Usage:
(let ([var1 expr1] ... [varn exprn]) body) expr1, ..., exprn are evaluated in an undefined order, has the appearance of running in parallel
The scope of var1, ..., varn is body
Note: vari is not in the scope of [varj, exprj] when i !</description></item></channel></rss>