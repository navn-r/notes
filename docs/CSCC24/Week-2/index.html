<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Week 2 #   Programming Languages define syntax formally.
   Lexical Rules: specify the form of the &lsquo;building blocks&rsquo; of a PL
 i.e. Comment Syntax, Tokens (keywords, literals, operators, etc.) and delimiters, White space    Syntax: specifies how the &lsquo;building blocks&rsquo; are put together
  Regular Expressions #  Notation #    Kleene Star (*): 0 or more repetitions
  Alternation (+ or |): denotes choice"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Week 2"><meta property="og:description" content="Week 2 #   Programming Languages define syntax formally.
   Lexical Rules: specify the form of the &lsquo;building blocks&rsquo; of a PL
 i.e. Comment Syntax, Tokens (keywords, literals, operators, etc.) and delimiters, White space    Syntax: specifies how the &lsquo;building blocks&rsquo; are put together
  Regular Expressions #  Notation #    Kleene Star (*): 0 or more repetitions
  Alternation (+ or |): denotes choice"><meta property="og:type" content="article"><meta property="og:url" content="https://navn-r.github.io/notes/CSCC24/Week-2/"><title>Week 2 - CSCC24</title><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@420&family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link rel=manifest href=/notes/manifest.json><link rel=icon href=/notes/favicon.png type=image/x-icon><link rel=stylesheet href=/notes/book.min.bb39aba330b9174b16ef802038db41db39c0787e5f90df566a5b5078e49a13c0.css integrity="sha256-uzmrozC5F0sW74AgONtB2znAeH5fkN9WaltQeOSaE8A="><script defer src=/notes/en.search.min.bee1c1a690511fe0f2265ddd770347a071c1fcfca0d223baef25dae57b267dfe.js integrity="sha256-vuHBppBRH+DyJl3ddwNHoHHB/Pyg0iO67yXa5Xsmff4="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/notes><span>&lt;✏️ /></span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-41f305c5e3122bf493595a858d4129a1 class=toggle>
<label for=section-41f305c5e3122bf493595a858d4129a1 class="flex justify-between"><a href=https://navn-r.github.io/notes/CSCA48/>CSCA48</a>
<span>▾</span></label><ul><li><a href=https://navn-r.github.io/notes/CSCA48/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-78a08a9976aa3e789bbd624f3262ce34 class=toggle>
<label for=section-78a08a9976aa3e789bbd624f3262ce34 class="flex justify-between"><a href=https://navn-r.github.io/notes/CSCB09/>CSCB09</a>
<span>▾</span></label><ul><li><a href=https://navn-r.github.io/notes/CSCB09/Week-1/>Week 1</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-2/>Week 2</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-3/>Week 3</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-4/>Week 4</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-5/>Week 5</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-6/>Week 6</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-7/>Week 7</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-8/>Week 8</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-9/>Week 9</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-10/>Week 10</a></li><li><a href=https://navn-r.github.io/notes/CSCB09/Week-11/>Week 11</a></li></ul></li><li><input type=checkbox id=section-f93fc08454e785bc3348bdfad48cbd90 class=toggle>
<label for=section-f93fc08454e785bc3348bdfad48cbd90 class="flex justify-between"><a href=https://navn-r.github.io/notes/CSCC01/>CSCC01</a>
<span>▾</span></label><ul><li><a href=https://navn-r.github.io/notes/CSCC01/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-717d341229bce3459525c2c9d3ec32a6 class=toggle checked>
<label for=section-717d341229bce3459525c2c9d3ec32a6 class="flex justify-between"><a href=https://navn-r.github.io/notes/CSCC24/>CSCC24</a>
<span>▾</span></label><ul><li><a href=https://navn-r.github.io/notes/CSCC24/Week-1/>Week 1</a></li><li><a href=https://navn-r.github.io/notes/CSCC24/Week-2/ class=active>Week 2</a></li></ul></li></ul><ul><li><a href=https://github.com/navn-r/notes target=_blank rel=noopener>Github Repo</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/notes/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Week 2</strong>
<label for=toc-control><img src=/notes/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#regular-expressions>Regular Expressions</a><ul><li></li></ul></li><li><a href=#grammars>Grammars</a><ul><li></li><li><a href=#context-free-grammars>Context-Free Grammars</a></li><li><a href=#regular-grammars>Regular Grammars</a></li><li><a href=#backus-naur-form-bnf>Backus-Naur Form (BNF)</a></li><li><a href=#derivations>Derivations</a></li><li><a href=#parse-trees>Parse Trees</a></li><li><a href=#syntactic-ambiguity>Syntactic Ambiguity</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=week-2>Week 2
<a class=anchor href=#week-2>#</a></h1><blockquote><p>Programming Languages define syntax <strong>formally</strong>.</p></blockquote><ul><li><p><strong>Lexical Rules</strong>: specify the form of the &lsquo;building blocks&rsquo; of a PL</p><ul><li>i.e. Comment Syntax, Tokens (keywords, literals, operators, etc.) and delimiters, White space</li></ul></li><li><p><strong>Syntax</strong>: specifies <em>how</em> the &lsquo;building blocks&rsquo; are put together</p></li></ul><h2 id=regular-expressions>Regular Expressions
<a class=anchor href=#regular-expressions>#</a></h2><h4 id=notation>Notation
<a class=anchor href=#notation>#</a></h4><ul><li><p><strong>Kleene Star</strong> (<code>*</code>): 0 or more repetitions</p></li><li><p><strong>Alternation</strong> (<code>+</code> or <code>|</code>): denotes choice</p></li><li><p><strong>Grouping</strong>: marked by parentheses <code>()</code></p></li><li><p><strong>Empty/Null String</strong>: denoted by epsilon: $\epsilon$</p></li><li><p><strong>Empty Language</strong>: language with <em>no strings</em>, denoted by $\empty$</p></li></ul><p>Examples:</p><pre><code>(0+1)*			0 or more of (&quot;0&quot; OR &quot;1&quot;) 

1*(:+;)*		0+ of &quot;1&quot;, 0+ of (&quot;:&quot; OR &quot;;&quot;)

(a+b)*aa(a+b)*  0+ of (&quot;a&quot; OR &quot;b&quot;), &quot;aa&quot;, 0+ of (&quot;a&quot; OR &quot;b&quot;)
</code></pre><h4 id=formal-definition>Formal Definition
<a class=anchor href=#formal-definition>#</a></h4><p>Let $\Sigma$ denote a finite alphabet. A given string is a <strong>Regular Expression (RE)</strong> <em>iff</em> it can be formed from <em>primitive REs</em>
$$
[\empty, \epsilon, \textrm{ any } a | a \in \Sigma ]
$$</p><h4 id=rules-of-applications-of-regular-expressions>Rules of Applications of Regular Expressions
<a class=anchor href=#rules-of-applications-of-regular-expressions>#</a></h4><blockquote><p>$a$ and $b$ are regular expressions</p></blockquote><ul><li><p>$a + b$: Union</p></li><li><p>$ab$ : Concatenation</p></li><li><p>$a^*$: Kleene Closure</p></li><li><p>$(a)$: Grouping</p></li><li><p>$\Sigma^{*}$: the set of all finite strings over the alphabet $\Sigma$</p></li></ul><h4 id=definition-of-a-regular-language>Definition of a Regular Language
<a class=anchor href=#definition-of-a-regular-language>#</a></h4><blockquote><p>Languages that can be expressed by <strong>Regular Expressions</strong>.</p></blockquote><p>Given a RE $r$ over an alphabet $\Sigma$, $L(r)$, <em>a language associated with</em> $r$ is defined by:</p><ul><li><p>$L(\empty)$: language that contains no strings</p></li><li><p>$L(\epsilon)$: language that only contains ${\epsilon}$</p></li><li><p>For $a \in \Sigma$, $L(a)$: language that only contains ${a}$</p></li></ul><h4 id=rules-of-regular-languages>Rules of Regular Languages
<a class=anchor href=#rules-of-regular-languages>#</a></h4><blockquote><p>$a$ and $b$ are regular expressions</p></blockquote><ul><li><p>$L(a + b) = L(a) \cup L(b)$</p></li><li><p>$L(ab) = L(a)L(b)$</p></li><li><p>$L((a)) = L(a)$</p></li><li><p>$L(a^<em>) = (L(a))^</em>,\text{ }S^*$ is the smallest superset of $S$ containing $\epsilon$ and is closed under concatenation</p></li></ul><hr><h2 id=grammars>Grammars
<a class=anchor href=#grammars>#</a></h2><ul><li><strong>Informal Grammar</strong>: just rules to follow<ul><li>i.e. &ldquo;Don&rsquo;t end a sentence with a preposition&rdquo;</li></ul></li><li><strong>Formal Grammar</strong><ul><li><p><strong>Language</strong>: set of strings</p></li><li><p><strong>Grammar</strong>: <em>specifies</em> which strings are in the language</p></li></ul></li></ul><h4 id=types-of-formal-grammar>Types of Formal Grammar
<a class=anchor href=#types-of-formal-grammar>#</a></h4><blockquote><p>Chomsky&rsquo;s Hierarchy: ordered by ascending expressiveness.</p></blockquote><ul><li>Regular Grammars</li><li>Context-Free Grammars</li><li>Context-Sensitive Grammars</li><li>Phase-Structure Grammars</li></ul><h3 id=context-free-grammars>Context-Free Grammars
<a class=anchor href=#context-free-grammars>#</a></h3><blockquote><p>More powerful than REs.</p></blockquote><h4 id=parts-of-a-context-free-grammar>Parts of a Context Free Grammar
<a class=anchor href=#parts-of-a-context-free-grammar>#</a></h4><ul><li><strong>Terminals</strong>: atomic symbols of the language</li><li><strong>Non-Terminals</strong>: &ldquo;variables&rdquo; used in the grammar</li><li><strong>Start Symbol</strong>: special non-terminal chosen as the top-level construct of the language</li><li>The first non-terminal listed is chosen as the start symbol by convention</li><li><strong>Productions</strong>: set of rules that specify legal ways that a non-terminal can be rewritten as a sequence of terminals and non-terminals</li></ul><h4 id=formal-definition-of-cfgs>Formal Definition of CFGs
<a class=anchor href=#formal-definition-of-cfgs>#</a></h4><p>A <strong>Context-Free Grammar</strong> $G$ is a tuple ${\Sigma, V, S, P}$ where</p><ul><li><p>$\Sigma$: set of terminals</p></li><li><p>$V$: set of non-terminals</p></li><li><p>$S$: Start Symbol where $S \in V$</p></li><li><p>$P$: set of productions</p><ul><li>Rule Form: $X \Longrightarrow w$, where $X \in V, w \in (\Sigma \cup V)^*$</li></ul></li></ul><p><strong><em>Note</em></strong>: $\Sigma \cap V = \empty$</p><ul><li><p>A <strong>Production Rule</strong> $X \Longrightarrow w$ can be applied to a string in the form of $sXt$ where $s,t \in (\Sigma \cup V)^*$ to produce a string $swt$</p></li><li><p>A grammar $G$ <em>generates</em> string $s$ if $\exists$ a finite sequence of applications of productions, such that the first rule is applied to the start symbol, and the last rule produces $s, s \in \Sigma^<em>$. Written as $G \Rightarrow^</em> s$.</p></li></ul><h5 id=definition-of-a-context-free-language>Definition of a Context-Free Language
<a class=anchor href=#definition-of-a-context-free-language>#</a></h5><blockquote><p>Languages that can be expressed by <strong>Context-Free Grammars</strong>.</p></blockquote><p>The <em>language generated</em> by a grammar $G$ is $L(G) = {s \mid G \Rightarrow^* s}$</p><h3 id=regular-grammars>Regular Grammars
<a class=anchor href=#regular-grammars>#</a></h3><blockquote><p>More restricted than CFGs.</p></blockquote><h4 id=productions-in-a-regular-grammar>Productions in a Regular Grammar
<a class=anchor href=#productions-in-a-regular-grammar>#</a></h4><ul><li><p><strong>Left Recursive</strong>: 0 or 1 non-terminal, appears as the <em>left-most</em> symbol on the RHS of the rule</p><pre><code>&lt;S&gt; ::= &lt;T&gt; a b	
&lt;T&gt; ::= a | &lt;T&gt; b
</code></pre></li><li><p><strong>Right Recursive</strong>: 0 or 1 non-terminal, appears as the <em>right-most</em> symbol on the RHS of rule</p><pre><code>&lt;S&gt; ::= a &lt;T&gt;
&lt;T&gt; ::= b &lt;T&gt; | a &lt;T&gt;
</code></pre></li></ul><h3 id=backus-naur-form-bnf>Backus-Naur Form (BNF)
<a class=anchor href=#backus-naur-form-bnf>#</a></h3><blockquote><p>The notation typically used to describe <strong>Context-Free Grammars</strong>.</p></blockquote><ul><li><strong>Non-Terminals</strong>: <code>&lt;NonTerminal></code></li><li><strong>OR</strong>: <code>|</code></li><li><strong>Productions</strong>: <code>LHS ::= RHS</code> <em>or</em> <code>LHS ==> RHS</code></li></ul><h4 id=extended-backus-naur-form-ebnf>Extended Backus-Naur Form (EBNF)
<a class=anchor href=#extended-backus-naur-form-ebnf>#</a></h4><blockquote><p>Extensions to BNF to make it more concise, but <strong><em>not</em></strong> more powerful</p></blockquote><ul><li><p><strong>Repetitions</strong>: <code>{ x }</code> - 0 or more repetitions of <code>x</code></p><ul><li>$x^+$: one or more repetitions</li><li>$x^n$: maximum of $n$ repetitions</li></ul></li><li><p><strong>Optional</strong>: <code>[ x ]</code> - 0 or 1 occurrences of <code>x</code></p></li><li><p><strong>Grouping</strong>: <code>()</code></p></li></ul><h3 id=derivations>Derivations
<a class=anchor href=#derivations>#</a></h3><blockquote><p>The sequence of applications of productions to generate a string.</p></blockquote><ul><li>A string is in the language generated by a grammar <strong><em>iff</em></strong> there is a derivation for it</li></ul><p>Example, Write <code>3.14</code> using the following CFG:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&lt;r&gt; <span style=color:#f92672>==</span>&gt; &lt;p&gt; . &lt;p&gt;
&lt;p&gt; <span style=color:#f92672>==</span>&gt; &lt;d&gt; | &lt;d&gt; &lt;p&gt;
&lt;d&gt; <span style=color:#f92672>==</span>&gt; <span style=color:#ae81ff>0</span> | ... | 9		<span style=color:#75715e># ... just means 1 through 8</span>
</code></pre></div><p>Solution:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&lt;r&gt; <span style=color:#f92672>==</span>&gt; &lt;p&gt; . &lt;p&gt;
	<span style=color:#f92672>==</span>&gt; &lt;d&gt; . &lt;d&gt; &lt;p&gt;
	<span style=color:#f92672>==</span>&gt; <span style=color:#ae81ff>3</span> . <span style=color:#ae81ff>1</span> &lt;d&gt;
	<span style=color:#f92672>==</span>&gt; <span style=color:#ae81ff>3</span> . <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>4</span>
</code></pre></div><h3 id=parse-trees>Parse Trees
<a class=anchor href=#parse-trees>#</a></h3><blockquote><p>Shows the structure within a string of the language.</p></blockquote><ul><li><p><strong>Parsing</strong> is the process of producing a parse tree.</p></li><li><p>A string is in the language generated by a grammar <strong><em>iff</em></strong> there is a parse tree for the string.</p></li></ul><h4 id=structure-of-a-parse-tree>Structure of a Parse Tree
<a class=anchor href=#structure-of-a-parse-tree>#</a></h4><ul><li><p><strong>Root</strong>: start symbol</p></li><li><p><strong>Leaf</strong>: terminal</p></li><li><p><strong>Internal Node</strong>: non-terminal</p><ul><li>Children correspond <em>in-order</em>, to the RHS of one of its products in the grammar</li></ul></li></ul><h3 id=syntactic-ambiguity>Syntactic Ambiguity
<a class=anchor href=#syntactic-ambiguity>#</a></h3><ul><li><p>A grammar is ambiguous <strong><em>iff</em></strong> it generates a string for where there are two or more <strong>Parse Trees</strong></p></li><li><p>A string is ambiguous w/r/t a grammar <strong><em>iff</em></strong> that grammar generates two or more <strong>Parse Trees</strong></p></li></ul><p><strong>Note</strong>: Two or more <em>derivations</em> does not mean a string is ambiguous.</p><h4 id=dealing-with-ambiguity>Dealing with Ambiguity
<a class=anchor href=#dealing-with-ambiguity>#</a></h4><ul><li><p>Include <strong>Delimiters</strong></p><ul><li>i.e. Curly Brackets, <code>fi</code>, etc.</li></ul></li><li><p>Impose <strong>Associativity</strong> and <strong>Precedence</strong></p><ul><li><p>i.e. Multiplication gets higher precedence than Addition</p></li><li><p>Introduce a non-terminal for each precedence level</p></li><li><p>For the same precedence level, operators can be</p><ul><li><p><strong>Left Associative</strong>: recursive term <em>before</em> non-recursive</p></li><li><p><strong>Right Associative</strong>: recursive term <em>after</em> non-recursive</p></li></ul></li></ul></li></ul><link rel=stylesheet href=/notes/katex/katex.min.css><script defer src=/notes/katex/katex.min.js></script><script defer src=/notes/katex/auto-render.min.js onload=renderMathInElement(document.body);></script><span>\(\)</span></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#regular-expressions>Regular Expressions</a><ul><li></li></ul></li><li><a href=#grammars>Grammars</a><ul><li></li><li><a href=#context-free-grammars>Context-Free Grammars</a></li><li><a href=#regular-grammars>Regular Grammars</a></li><li><a href=#backus-naur-form-bnf>Backus-Naur Form (BNF)</a></li><li><a href=#derivations>Derivations</a></li><li><a href=#parse-trees>Parse Trees</a></li><li><a href=#syntactic-ambiguity>Syntactic Ambiguity</a></li></ul></li></ul></nav></div></aside></main><script defer src=/notes/katex/auto-render.min.js onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},],});"></script></body></html>