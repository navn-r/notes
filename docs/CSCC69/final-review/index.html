<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="CSCC69 - Final Review # Winter 2023 # We both know I shouldn&rsquo;t be writing a review for this course.
Threads # Concurrency # Running multiple processes at the same time
Able to run more processes than the number of cores Serial execution results in more CPU idle time waiting for I/O User threads are 1:1 mapped to kernel threads (struct thread), can also be many:1 The OS also has its own kernel threads Interrupts # CPU stops running current process, saves its state, and runs interrupt handler (threads/interrupt."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Final Review"><meta property="og:description" content="CSCC69 - Final Review # Winter 2023 # We both know I shouldn&rsquo;t be writing a review for this course.
Threads # Concurrency # Running multiple processes at the same time
Able to run more processes than the number of cores Serial execution results in more CPU idle time waiting for I/O User threads are 1:1 mapped to kernel threads (struct thread), can also be many:1 The OS also has its own kernel threads Interrupts # CPU stops running current process, saves its state, and runs interrupt handler (threads/interrupt."><meta property="og:type" content="article"><meta property="og:url" content="https://navn.me/notes/CSCC69/final-review/"><meta property="article:section" content="CSCC69"><title>Final Review - CSCC69</title><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@420&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap" rel=stylesheet><link rel=manifest href=/notes/manifest.json><link rel=icon href=/notes/favicon.png type=image/x-icon><link rel=stylesheet href=/notes/book.min.5b161a410a07e8edac1f3ac3960626c8f0526b5c27cd5e3521db29c8d38dcb70.css integrity="sha256-WxYaQQoH6O2sHzrDlgYmyPBSa1wnzV41IdspyNONy3A="><script defer src=/notes/flexsearch.min.js></script>
<script defer src=/notes/en.search.min.be0e9d025299524686e600c970c835dbdfe19270db2898dbd31a9a0af278027b.js integrity="sha256-vg6dAlKZUkaG5gDJcMg129/hknDbKJjb0xqaCvJ4Ans=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/notes/><img src=/notes/logo.svg alt=Logo><span>Notes</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-41f305c5e3122bf493595a858d4129a1 class=toggle>
<label for=section-41f305c5e3122bf493595a858d4129a1 class="flex justify-between"><a href=https://navn.me/notes/CSCA48/>CSCA48</a></label><ul><li><a href=https://navn.me/notes/CSCA48/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-78a08a9976aa3e789bbd624f3262ce34 class=toggle>
<label for=section-78a08a9976aa3e789bbd624f3262ce34 class="flex justify-between"><a href=https://navn.me/notes/CSCB09/>CSCB09</a></label><ul><li><a href=https://navn.me/notes/CSCB09/Week-1/>Week 1</a></li><li><a href=https://navn.me/notes/CSCB09/Week-2/>Week 2</a></li><li><a href=https://navn.me/notes/CSCB09/Week-3/>Week 3</a></li><li><a href=https://navn.me/notes/CSCB09/Week-4/>Week 4</a></li><li><a href=https://navn.me/notes/CSCB09/Week-5/>Week 5</a></li><li><a href=https://navn.me/notes/CSCB09/Week-6/>Week 6</a></li><li><a href=https://navn.me/notes/CSCB09/Week-7/>Week 7</a></li><li><a href=https://navn.me/notes/CSCB09/Week-8/>Week 8</a></li><li><a href=https://navn.me/notes/CSCB09/Week-9/>Week 9</a></li><li><a href=https://navn.me/notes/CSCB09/Week-10/>Week 10</a></li><li><a href=https://navn.me/notes/CSCB09/Week-11/>Week 11</a></li></ul></li><li><input type=checkbox id=section-f93fc08454e785bc3348bdfad48cbd90 class=toggle>
<label for=section-f93fc08454e785bc3348bdfad48cbd90 class="flex justify-between"><a href=https://navn.me/notes/CSCC01/>CSCC01</a></label><ul><li><a href=https://navn.me/notes/CSCC01/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-717d341229bce3459525c2c9d3ec32a6 class=toggle>
<label for=section-717d341229bce3459525c2c9d3ec32a6 class="flex justify-between"><a href=https://navn.me/notes/CSCC24/>CSCC24</a></label><ul><li><a href=https://navn.me/notes/CSCC24/Week-1/>Week 1</a></li><li><a href=https://navn.me/notes/CSCC24/Week-2/>Week 2</a></li><li><a href=https://navn.me/notes/CSCC24/Week-3/>Week 3</a></li><li><a href=https://navn.me/notes/CSCC24/Week-4/>Week 4</a></li><li><a href=https://navn.me/notes/CSCC24/Week-5/>Week 5</a></li><li><a href=https://navn.me/notes/CSCC24/Week-6/>Week 6</a></li><li><a href=https://navn.me/notes/CSCC24/Week-7/>Week 7</a></li><li><a href=https://navn.me/notes/CSCC24/Week-8/>Week 8</a></li><li><a href=https://navn.me/notes/CSCC24/Week-9/>Week 9</a></li><li><a href=https://navn.me/notes/CSCC24/Week-10/>Week 10</a></li></ul></li><li><input type=checkbox id=section-63a4e50557aed8f6e298fc725d63cc32 class=toggle>
<label for=section-63a4e50557aed8f6e298fc725d63cc32 class="flex justify-between"><a href=https://navn.me/notes/CSCC43/>CSCC43</a></label><ul><li><a href=https://navn.me/notes/CSCC43/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-07443dba2f48ea6bd23fc5ebe65364b1 class=toggle checked>
<label for=section-07443dba2f48ea6bd23fc5ebe65364b1 class="flex justify-between"><a href=https://navn.me/notes/CSCC69/>CSCC69</a></label><ul><li><a href=https://navn.me/notes/CSCC69/final-review/ class=active>Final Review</a></li></ul></li></ul><ul><li><a href=https://github.com/navn-r/notes target=_blank rel=noopener>Github Repo</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/notes/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Final Review</strong>
<label for=toc-control><img src=/notes/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#threads>Threads</a><ul><li><a href=#concurrency>Concurrency</a></li><li><a href=#synchronization>Synchronization</a></li><li><a href=#scheduling>Scheduling</a></li></ul></li><li><a href=#virtual-memory>Virtual Memory</a><ul><li><a href=#attempts-to-solve-virtual-memory>Attempts to Solve Virtual Memory</a></li><li><a href=#page-replacement>Page Replacement</a></li><li><a href=#memory-allocation>Memory Allocation</a></li></ul></li><li><a href=#storage-devices>Storage Devices</a><ul><li><a href=#purpose>Purpose</a></li><li><a href=#hard-disk-drives>Hard Disk Drives</a></li><li><a href=#solid-state-drives>Solid State Drives</a></li></ul></li><li><a href=#file-systems>File Systems</a><ul><li><a href=#goals>Goals</a></li><li><a href=#disk-layout>Disk Layout</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=cscc69---final-review>CSCC69 - Final Review
<a class=anchor href=#cscc69---final-review>#</a></h1><h4 id=winter-2023>Winter 2023
<a class=anchor href=#winter-2023>#</a></h4><blockquote><p>We both know I shouldn&rsquo;t be writing a review for this course.</p></blockquote><h2 id=threads>Threads
<a class=anchor href=#threads>#</a></h2><h3 id=concurrency>Concurrency
<a class=anchor href=#concurrency>#</a></h3><blockquote><p>Running multiple processes at the same time</p></blockquote><ul><li>Able to run more processes than the number of cores</li><li>Serial execution results in more CPU idle time waiting for I/O</li><li>User threads are 1:1 mapped to kernel threads (<code>struct thread</code>), can also be many:1</li><li>The OS also has its own kernel threads</li></ul><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1098762573832265858/image.png alt="kernel threads"></p><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1098763231507529778/image.png alt="process vs threads"></p><h4 id=interrupts>Interrupts
<a class=anchor href=#interrupts>#</a></h4><ul><li>CPU stops running current process, saves its state, and runs interrupt handler (<code>threads/interrupt.c</code>)</li><li><strong>External</strong>: Programmable Interrupt Controller (PIC) handles hardware interrupts</li><li><strong>Internal</strong>: Timer interrupts, Syscalls, Faults (page, segmentation, division by zero)</li></ul><h3 id=synchronization>Synchronization
<a class=anchor href=#synchronization>#</a></h3><ul><li>Incrementing and Decrementing are not atomic, may cause race conditions</li></ul><h4 id=critical-section>Critical Section
<a class=anchor href=#critical-section>#</a></h4><ul><li>Code that accesses shared data and must be executed atomically</li></ul><table><thead><tr><th>Requirement</th><th>Definition</th></tr></thead><tbody><tr><td>Mutual Exclusion</td><td>Only one thread can be in critical section at a time</td></tr><tr><td>Progress</td><td>A thread in the critical section will eventually exit</td></tr><tr><td>Bounded Waiting</td><td>If a thread is waiting to enter critical section, eventually it will</td></tr><tr><td>Performance</td><td>No thread should wait too long to enter critical section</td></tr></tbody></table><ul><li><p><strong>Disable Interrupts</strong>: Technically works, but can cause deadlock (thread hangs forever)</p></li><li><p><strong>Semaphores</strong>: Accessed by multiple threads</p><ul><li>Contains a counter (> 0) and a list of waiting threads</li><li>Before entering critical section, down the semaphore</li><li>After, up the semaphore, waking up another thread</li></ul></li><li><p><strong>Locks</strong>: Acquired and released by a single thread (binary semaphore)</p></li><li><p><strong>Condition Variables</strong>: Waits for a condition to be true</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>cond_init</span> (<span style=color:#f92672>&amp;</span>cond);
</span></span><span style=display:flex><span><span style=color:#a6e22e>cond_wait</span> (<span style=color:#f92672>&amp;</span>cond, <span style=color:#f92672>&amp;</span>lock); <span style=color:#75715e>// thread calls this to wait for condition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cond_signal</span> (<span style=color:#f92672>&amp;</span>cond);      <span style=color:#75715e>// wakes up one waiter 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cond_broadcast</span> (<span style=color:#f92672>&amp;</span>cond);   <span style=color:#75715e>// wakes all threads
</span></span></span></code></pre></div></li></ul><h4 id=deadlock>Deadlock
<a class=anchor href=#deadlock>#</a></h4><ul><li>No process can make progress because each is waiting for an event that only another process can cause</li><li>Avoided by acquiring resources in a fixed order (no circular wait)</li></ul><table><thead><tr><th>Condition</th><th>Definition</th></tr></thead><tbody><tr><td>Mutual Exclusion</td><td>One process at a time can use the resource</td></tr><tr><td>Hold and Wait</td><td>A process is holding at least one resource and waiting for additional resources</td></tr><tr><td>No Preemption</td><td>A resource can be released only voluntarily by the process holding it</td></tr><tr><td>Circular Wait</td><td>P1 waiting on P2 waiting on &mldr; PN waiting on P1</td></tr></tbody></table><h3 id=scheduling>Scheduling
<a class=anchor href=#scheduling>#</a></h3><h4 id=thread-lifecycle>Thread Lifecycle
<a class=anchor href=#thread-lifecycle>#</a></h4><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1098736585861759047/image.png alt="thread lifecycle diagram"></p><ul><li><strong>Scheduling Problem</strong>: Given a set of processes, decide which process to run next, and for how long</li><li><strong>Starvation</strong>: Thread is prevented from making progress because some other thread has the resources it needs<ul><li>i.e. a higher priority thread is preventing the lower priority thread from running</li></ul></li></ul><h4 id=scheduling-metrics>Scheduling Metrics
<a class=anchor href=#scheduling-metrics>#</a></h4><table><thead><tr><th>Metric</th><th>Definition</th></tr></thead><tbody><tr><td>Throughput</td><td>Number of processes that complete per unit time (maximize)</td></tr><tr><td>Turnaround</td><td><code>time_finished</code> $-$ <code>time_started</code> (minimize)</td></tr><tr><td>Response</td><td><code>time_responded</code> $-$ <code>time_requested</code> (minimize)</td></tr></tbody></table><h4 id=scheduling-algorithms>Scheduling Algorithms
<a class=anchor href=#scheduling-algorithms>#</a></h4><table><thead><tr><th>Kind</th><th>Definition</th></tr></thead><tbody><tr><td>Preemptive</td><td>OS can switch to another thread at any time</td></tr><tr><td>Non-Preemptive</td><td>OS can only switch to another thread after the running thread terminates</td></tr></tbody></table><ul><li><p><strong>First-Come, First-Served (FCFS)</strong>: Can cause head-of-line blocking (long processes block short processes)</p></li><li><p><strong>Shortest Job First (SJF)</strong>: Must know processing time, can cause starvation (short processes starve long processes)</p><ul><li>SRTF: Can consider remaining time instead of total time (preemptive), still leads to starvation</li></ul></li><li><p><strong>Round Robin (RR)</strong>: Preempt current thread after time quantum (1-100ms), and continue in FIFO order</p><ul><li>Doesn&rsquo;t consider a thread&rsquo;s priority, can cause starvation</li></ul></li><li><p><strong>Multilevel Feedback Queue Scheduling (MLFQS)</strong>: Preemptive, priority-based scheduling</p><ol><li>Assigned high priority initially, and priority is decreased after each time quantum</li><li>A Lower priority runs only when the higher priority queue is empty</li><li>If same priority, round robin is used</li><li>After a job uses up its time quantum, it moves to the lower priority queue</li><li>After some time, all jobs are moved back to higher priority</li></ol></li></ul><h4 id=priority-donation>Priority Donation
<a class=anchor href=#priority-donation>#</a></h4><ul><li>A thread can donate to a lower priority thread</li><li>Eg. Thread H waiting for a lock held by a thread L<ul><li>H donates to L, allowing L to schedule and release the lock</li><li>L returns the donation back to H to continue running</li></ul></li></ul><pre tabindex=0><code>NESTED DONATION: &#34;H is waiting on A held by M and M is waiting on B held by L&#34;

|-------------------|                               |-------------------|                               |--------------------|
| thread H          |       |-------------|         | thread M          |       |-------------|         | thread L           |
|   priority: HIGH  |       | lock A      |         |   priority: MED   |       | lock B      |         |   priority: LOW    |
|   waiting_on: A   |------&gt;|   holder: M |--------&gt;|   waiting_on: B   |------&gt;|  holder: L  |--------&gt;|   waiting_on: NULL |
|___________________|       |_____________|         |___________________|       |_____________|         |____________________|
</code></pre><h2 id=virtual-memory>Virtual Memory
<a class=anchor href=#virtual-memory>#</a></h2><ul><li>Abstraction of physical memory</li><li>Each process has its own virtual address space</li><li>OS maps virtual addresses to physical addresses without the process knowing other processes&rsquo; addresses</li><li><strong>Fragmentation</strong>: Inability to use memory over time, avoiding this is impossible<ul><li><strong>Internal</strong>: Fixed size pieces, internal waste of space</li><li><strong>External</strong>: Free space is not contiguous, can&rsquo;t allocate a large block (many small holes)</li><li>Factors required for Fragmentation:<ul><li>Different lifetimes: no fragmentation if all processes have same lifetime</li><li>Different sizes: no fragmentation if all processes have same size</li></ul></li></ul></li></ul><table><thead><tr><th>Goal</th><th>Definition</th></tr></thead><tbody><tr><td>Protection</td><td>Each process has its own virtual address space</td></tr><tr><td>Efficiency</td><td>Reduce memory usage and improve performance</td></tr><tr><td>Convenience</td><td>Allow processes to use memory without worrying about physical memory</td></tr><tr><td>Extensibility</td><td>Allow processes to use more memory than physical memory</td></tr></tbody></table><h3 id=attempts-to-solve-virtual-memory>Attempts to Solve Virtual Memory
<a class=anchor href=#attempts-to-solve-virtual-memory>#</a></h3><ol><li><p><strong>Base and Bound Registers</strong></p><ul><li>MMU translates (and verifies) address at runtime</li><li><code>physical_address = virtual_address - base</code></li><li>If <code>base &lt;= address &lt;= bound</code>, then address is valid, else trap to OS</li><li>Causes internal fragmentation, growing process is expensive</li></ul></li><li><p><strong>Segmentation</strong></p><ul><li>Divide process into segments, each with its own base and bound</li><li>Address is built from segmentation table</li><li>Causes external fragmentation</li></ul></li><li><p><strong>Simple Paging</strong></p><ul><li>Divide virtual memory into fixed-size pages, physical memory into paged-sized frames</li><li>Each page has a page table entry (PTE) that maps virtual page to physical page</li><li>Eliminates external fragmentation, internal fragmentation is small</li><li>Each memory lookup requires two memory accesses (page table and PTE)</li></ul></li></ol><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1098926036168736808/image.png alt="address lookup"></p><ol start=4><li><strong>Multi-Level Paging</strong><ul><li>Page directory contains one entry per page table (<code>pagedir</code>)</li><li>Lookup process: (happy path)<ol><li>Fetch PTE from PDE</li><li>Fetch page frame from PTE</li><li>Compute physical address from page frame and offset</li></ol></li><li>If any of the above steps fail, a page fault occurs (<code>userprog/exception.c:page_fault()</code>)</li><li>Allows for page growth, but now requires 3 memory accesses (time-space trade-off)</li><li><strong>Translation Lookaside Buffer (TLB)</strong>: Cache of recently used PTEs, reduces memory accesses to 2<ul><li>High hit rate, maintained by the MMU (hardware is always faster than software)</li></ul></li></ul></li></ol><h3 id=page-replacement>Page Replacement
<a class=anchor href=#page-replacement>#</a></h3><ul><li><strong>Swap</strong>: Move a page from physical memory to disk</li><li>When a page fault occurs, the OS must choose a page to evict from physical memory into swap</li><li>Page replacement algorithms strive to minimize page fault rate</li><li><strong>Belady&rsquo;s Anomaly</strong>: Having more physical memory does not automatically mean fewer page faults</li></ul><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1098935002638598184/image.png alt="page replacement"></p><h4 id=page-replacement-algorithms>Page Replacement Algorithms
<a class=anchor href=#page-replacement-algorithms>#</a></h4><ol><li><strong>Basic algorithms</strong>: FIFO, LRU, LFU, MFU</li></ol><ul><li>Combinations also exist</li></ul><ol start=2><li><strong>Clock Algorithm</strong>: Approximation of LRU</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>list_init</span> (frame_list); <span style=color:#75715e>// circular
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>clock_hand <span style=color:#f92672>=</span> frame_list.head; <span style=color:#75715e>// some page frame
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (each page access request)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (page in memory) <span style=color:#75715e>// hit 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  {
</span></span><span style=display:flex><span>    page.accessed <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#75715e>// miss (eviction)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (clock_hand.accessed <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      clock_hand.accessed <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      clock_hand <span style=color:#f92672>=</span> clock_hand.next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>swap</span> (clock_hand, page);
</span></span><span style=display:flex><span>    clock_hand <span style=color:#f92672>=</span> clock_hand.next;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li><strong>Second Chance</strong>: Similar to clock algorithm, head of list after is ready to be evicted</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>second_chance</span> (<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>thread</span> <span style=color:#f92672>*</span>cur <span style=color:#f92672>=</span> <span style=color:#a6e22e>thread_current</span> ();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> frame_table_entry <span style=color:#f92672>*</span>frame <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_head_frame</span> ();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sup_page_entry <span style=color:#f92672>*</span>spe <span style=color:#f92672>=</span> frame<span style=color:#f92672>-&gt;</span>spe;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>pagedir_is_accessed</span> (frame<span style=color:#f92672>-&gt;</span>owner<span style=color:#f92672>-&gt;</span>pagedir, spe<span style=color:#f92672>-&gt;</span>uaddr))
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pagedir_set_accessed</span> (frame<span style=color:#f92672>-&gt;</span>owner<span style=color:#f92672>-&gt;</span>pagedir, spe<span style=color:#f92672>-&gt;</span>uaddr, false);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &#39;rotate&#39; frame to the back of the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>list_remove</span> (<span style=color:#f92672>&amp;</span>frame<span style=color:#f92672>-&gt;</span>elem);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>list_push_back</span> (<span style=color:#f92672>&amp;</span>frame_table, <span style=color:#f92672>&amp;</span>frame<span style=color:#f92672>-&gt;</span>elem);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    frame <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_head_frame</span> ();
</span></span><span style=display:flex><span>    spe <span style=color:#f92672>=</span> frame<span style=color:#f92672>-&gt;</span>spe;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=memory-allocation>Memory Allocation
<a class=anchor href=#memory-allocation>#</a></h3><ul><li><strong>Static</strong>: Memory is allocated at compile time (fixed size, stack)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>100</span>]; <span style=color:#75715e>// simple, but restricted
</span></span></span></code></pre></div></li><li><strong>Dynamic</strong>: Memory is allocated at runtime (variable size, heap)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>a <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) <span style=color:#a6e22e>malloc</span> (<span style=color:#ae81ff>100</span>); <span style=color:#75715e>// contiguous block of memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>free</span> (a); <span style=color:#75715e>// creates fragmentation (need to coalesce)
</span></span></span></code></pre></div></li></ul><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1099368064115544164/image.png alt="heap memory allocator"></p><h4 id=allocator-data-structures>Allocator Data Structures
<a class=anchor href=#allocator-data-structures>#</a></h4><ol><li><p><strong>Bitmap</strong>: Array of bits, each bit represents a page</p><ul><li>0 means free, 1 means allocated</li><li>Allocation is slow, requires linear scan to find sequence of zeros</li><li>No need to coalesce</li></ul></li><li><p><strong>Free List</strong>: List of free pages</p><ul><li>Coalescing is required to prevent fragmentation, merge adjacent blocks</li></ul></li></ol><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1099368859468824657/image.png alt="free list"></p><h4 id=placement-algorithms>Placement Algorithms
<a class=anchor href=#placement-algorithms>#</a></h4><ol><li><p><strong>First Fit</strong>: Find first free block that is large enough</p><ul><li>Linear scan of free list sorted LIFO/FIFO/address, pick first one that is large enough</li><li>Simple, (often) fastest and most efficient</li><li>May cause fragmentation near start of memory that must be searched repeatedly</li></ul></li><li><p><strong>Best Fit</strong>: Find smallest free block that is large enough</p><ul><li>Minimize fragmentation by allocating space from block that leaves smallest fragment</li><li>Requires linear scan of free list</li><li><strong>Worst Fit</strong>: Find largest free block that is large enough (opposite of best fit)</li></ul></li><li><p><strong>Buddy Allocation</strong>: Round up allocations to power of 2 to make management faster</p><ul><li>Fast search and merge (alloc and free)</li><li>Avoids iterating through free list</li><li>Avoids external fragmentation</li><li>Physical pages are kept contiguous</li></ul></li></ol><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1099373037352144986/image.png alt="buddy allocation"></p><h2 id=storage-devices>Storage Devices
<a class=anchor href=#storage-devices>#</a></h2><h3 id=purpose>Purpose
<a class=anchor href=#purpose>#</a></h3><ul><li><p>It is the OS&rsquo;s responsibility to abstract storage details</p><ul><li>HDD only knows about platters and sectors, SSD only knows about pages and blocks</li><li>Neither know about files, directories, or processes, but user programs do</li></ul></li><li><p><strong>Memory/Storage Hierarchy</strong>:</p><ul><li>Balance between cost, performance, and capacity</li><li>CPU registers and cache are fastest, but small and expensive</li><li>Hard disk is slow, but large and cheap</li><li>Exploit locality of reference to minimize cost</li></ul></li><li><p><strong>Persistence</strong>:</p><ul><li>&lsquo;Permanent&rsquo; storage of data</li><li>Organization, consistency, and management issues are important</li></ul></li></ul><h3 id=hard-disk-drives>Hard Disk Drives
<a class=anchor href=#hard-disk-drives>#</a></h3><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1099378387560173679/image.png alt=insides></p><ul><li><p>Slow for random access</p></li><li><p>HDD workloads favor high locality and large request sizes</p><ul><li>Should design FS to generate workloads that have this</li></ul></li><li><p>Disk service time components:</p><ul><li>Seeking (expensive)</li><li>Rotational Latency (spinning)</li><li>Data transfer (reading/writing)</li></ul></li><li><p>Disks expose storage as a linear array of blocks</p><ul><li>Blocks are 512 bytes</li><li>Can read/write whole blocks (nothing partial)</li><li>Actual location of block is unknown to the OS</li></ul></li></ul><p><strong>Preventing Failures</strong></p><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1099384418310832148/image.png alt=redundancy></p><h3 id=solid-state-drives>Solid State Drives
<a class=anchor href=#solid-state-drives>#</a></h3><ul><li><p>Based on NAND flash cells, and have no moving parts</p><ul><li><strong>SLC</strong>: Single Level Cell (1 bit per cell)</li><li><strong>QLC</strong>: Quad Level Cell (4 bits per cell)</li></ul></li><li><p>Faster, reliable, and more power efficient than HDD</p><ul><li>But can only be written/erased to a limited number of times</li></ul></li><li><p>Cells are organized into <strong>pages</strong></p></li><li><p>Pages are organized into <strong>Erase Blocks</strong> (not the same as disk blocks)</p><ul><li>Writes are only possible to erased pages</li></ul></li><li><p>Writes are 10x slower than reads, Erases are 10x slower than writes</p></li><li><p>Erase Blocks are the smallest unit that can be erased</p><ul><li>Causes fragmentation, requires garbage collection, usually done in the background</li><li>GC copies over an entire block to a new block, then erases the old (fragmented) block</li><li>SSDs overprovision to account for this (240GB SSD has 256GB of storage)</li></ul></li><li><p>GC and Wear levelling (solution to fixed number of writes) case <strong>Write Amplification</strong>:</p><ul><li>The number of writes to the SSD is greater than the number of writes to the file system</li></ul></li></ul><p><img src=https://cdn.discordapp.com/attachments/975189796412604480/1099391690730635344/image.png alt="ssd firmware"></p><h2 id=file-systems>File Systems
<a class=anchor href=#file-systems>#</a></h2><h3 id=goals>Goals
<a class=anchor href=#goals>#</a></h3><ol><li><strong>Abstraction</strong>: Hide details of storage devices from user programs (files)<ul><li>Developed using a generic block layer (does not matter if HDD or SSD)</li></ul></li><li><strong>Organization</strong>: Organize files into directories (logically)</li><li><strong>Sharing</strong>: Allow processes, users, and machines to share files</li><li><strong>Security</strong>: Protect files from unauthorized access</li></ol><h3 id=disk-layout>Disk Layout
<a class=anchor href=#disk-layout>#</a></h3><ul><li><strong>inode</strong>: Data structure to represent a file (<code>struct inode</code>)<ul><li>Metadata: File size, permissions, owner, etc.</li><li>Tracks which blocks (on disk) contains the data stored in the file (<code>struct inode_disk</code>)</li></ul></li></ul><h4 id=layout-strategies>Layout Strategies
<a class=anchor href=#layout-strategies>#</a></h4><ol><li><p><strong>Contiguous Allocation</strong>: Allocate blocks in a contiguous sequence</p><ul><li>Simple, only need to keep track of offset and length of file</li><li>Causes external fragmentation, gaps when a file is deleted</li></ul></li><li><p><strong>Linked Allocation</strong>: Allocate blocks in a linked list</p><ul><li>Each block points to the next block in the file</li><li>Doesn&rsquo;t have to be contiguous, need to keep track of first and last block pointer</li><li>Good for sequential access, bad for all others</li></ul></li><li><p><strong>Indexed Allocation</strong>: Multi-level indirect blocks</p><ul><li>&lsquo;Index&rsquo; block (indirect, double indirect, triple indirect) points to other blocks</li><li>Need to store the index blocks on disk as well</li><li>Allows for very large and extendable files</li><li><strong>Freemap</strong>: Bitmap of free blocks, used to allocate new blocks<ul><li>Only need to allocate bit by bit, not contiguously</li></ul></li></ul></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#threads>Threads</a><ul><li><a href=#concurrency>Concurrency</a></li><li><a href=#synchronization>Synchronization</a></li><li><a href=#scheduling>Scheduling</a></li></ul></li><li><a href=#virtual-memory>Virtual Memory</a><ul><li><a href=#attempts-to-solve-virtual-memory>Attempts to Solve Virtual Memory</a></li><li><a href=#page-replacement>Page Replacement</a></li><li><a href=#memory-allocation>Memory Allocation</a></li></ul></li><li><a href=#storage-devices>Storage Devices</a><ul><li><a href=#purpose>Purpose</a></li><li><a href=#hard-disk-drives>Hard Disk Drives</a></li><li><a href=#solid-state-drives>Solid State Drives</a></li></ul></li><li><a href=#file-systems>File Systems</a><ul><li><a href=#goals>Goals</a></li><li><a href=#disk-layout>Disk Layout</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=/notes/katex/katex.min.css><script defer src=/notes/katex/katex.min.js></script>
<script defer src=/notes/katex/auto-render.min.js onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script></body></html>