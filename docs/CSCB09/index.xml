<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSCB09 on &lt;✏️ /&gt;</title>
    <link>http://navn-r.github.io/notes/CSCB09/</link>
    <description>Recent content in CSCB09 on &lt;✏️ /&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Jun 2020 00:06:17 +0000</lastBuildDate>
    
	<atom:link href="http://navn-r.github.io/notes/CSCB09/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Week 1</title>
      <link>http://navn-r.github.io/notes/CSCB09/Week-1/</link>
      <pubDate>Wed, 20 May 2020 14:33:50 +0000</pubDate>
      
      <guid>http://navn-r.github.io/notes/CSCB09/Week-1/</guid>
      <description>Week 1 Processes  What happens when you run a program.
   Has Input and Output ends:
 stdin: Standard Input - eg. Keyboard input goes through stdin stdout: Standard Output - eg. Terminal output (printing to screen)  eg.
Navinns-MacBook-Pro:~ home$ sort # OS connects keyboard to stdin Watermelon Apple Strawberry Mango ^D # &amp;#39;exit&amp;#39; keybind, OS connects screen to stdout Apple Mango Strawberry Watermelon   Pipelining and Redirection  Routing outputs of one program to the input of another, and outputting to a file instead of the screen.</description>
    </item>
    
    <item>
      <title>Week 2</title>
      <link>http://navn-r.github.io/notes/CSCB09/Week-2/</link>
      <pubDate>Tue, 26 May 2020 17:52:24 +0000</pubDate>
      
      <guid>http://navn-r.github.io/notes/CSCB09/Week-2/</guid>
      <description>Week 2 File Management  How we survived without File Explorer
 Directory Tree / ├── Applications ├── Library ├── System ├── *Users* ├── Volumes ├── bin ├── cores ├── *dev* ├── etc -&amp;gt; private/etc ├── *home* -&amp;gt; /System/Volumes/Data/home ├── opt ├── private ├── sbin ├── tmp -&amp;gt; private/tmp ├── *usr* └── var -&amp;gt; private/var Paths   Absolute Path: from root dir
 eg. /Users/home/projects/course-notes/index.html    Relative Path: from current dir</description>
    </item>
    
    <item>
      <title>Week 3</title>
      <link>http://navn-r.github.io/notes/CSCB09/Week-3/</link>
      <pubDate>Tue, 02 Jun 2020 17:42:22 +0000</pubDate>
      
      <guid>http://navn-r.github.io/notes/CSCB09/Week-3/</guid>
      <description>Week 3 Introduction to Shell  More features available from man sh
 Simple Commands 4 general cases of commands
 Built in commands: cd, ls etc. User defined functions Aliases eg. alias pls=&amp;quot;sudo&amp;quot; Commands that refer to the program name  eg. tr command runs the tr program    Sequential List Multi-line commands in a single line
$ cd projects ; sort file1 | uniq # runs cd then runs sort with pipe # equivalent to $ cd projects projects$ sort file1 | uniq  Grouping:  Explicit: {grep foo file1 ; ls ; } &amp;gt; file2    Exit Codes 0 for success, non-0 for failure</description>
    </item>
    
    <item>
      <title>Week 4</title>
      <link>http://navn-r.github.io/notes/CSCB09/Week-4/</link>
      <pubDate>Tue, 02 Jun 2020 19:14:38 +0000</pubDate>
      
      <guid>http://navn-r.github.io/notes/CSCB09/Week-4/</guid>
      <description>Week 4 Shell Scripting Running Scripts $ sh myscript Alternatively, in your myscript.sh file, do the following
#! /bin/sh chmod u+x myscript # sets &amp;#39;executable&amp;#39; flag on the file and run it with&amp;hellip;
$ ./myscript Positional Parameters $ ./myscript foo bar baz # come after filename, spaced  $#: Number of arguments (3) $n: Parameter name (n is the number)  eg. $1 = &amp;quot;foo&amp;quot;   $*: One string with all parameter names  &amp;quot;foo bar baz&amp;quot;   $@: Comma seperated strings for each parameter name  &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;   shift: Shifts Positional Parameters by 1 $# = 2 $1 = &amp;#34;bar&amp;#34; $2 = &amp;#34;baz&amp;#34; $* = &amp;#34;bar baz&amp;#34; # good for looping over parameters   Example Script #!</description>
    </item>
    
    <item>
      <title>Week 5</title>
      <link>http://navn-r.github.io/notes/CSCB09/Week-5/</link>
      <pubDate>Wed, 10 Jun 2020 17:30:31 +0000</pubDate>
      
      <guid>http://navn-r.github.io/notes/CSCB09/Week-5/</guid>
      <description>Week 5 Programming in C Memory Model  Array of bytes, &amp;ldquo;Addresses&amp;rdquo; are indexes Variables may occupy several consecutive bytes, its address refers to the first occupied byte &amp;ldquo;Pointer&amp;rdquo;: Variable/parameter that stores an address  int i = 69; // Suppose i was occupying bytes 45 to 74 int *p = &amp;amp;i // 45 Memory Regions  Text:  Stores code Pointers pointing to functions point here   Global:  Stores global variables   Stack:  Used for function calls Stores local variables Auto allocation and deallocation   Heap:  Manual allocation (malloc(), calloc()) and deallocation (free()) Used for dynamic data outside of functions    Global Variables  Two types of varaibles int pubVar = 10; // top-level public global variable int f() { static int privVar = 1010; // function private global variable  pubVar++; privVar++; .</description>
    </item>
    
    <item>
      <title>Week 6</title>
      <link>http://navn-r.github.io/notes/CSCB09/Week-6/</link>
      <pubDate>Wed, 17 Jun 2020 00:06:17 +0000</pubDate>
      
      <guid>http://navn-r.github.io/notes/CSCB09/Week-6/</guid>
      <description>Week 6 Programming in C (cont.) File I/O in C  Content can be accessed as a steam (seq. read/write) File functions work with FILE *  FILE: Type rep. stream state, definition varies by platform, most likely a struct    Open FILE *fopen(const char *filename, const char *mode)  Modes: &amp;quot;r&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;r+&amp;quot;, &amp;quot;w+&amp;quot;, &amp;quot;a+&amp;quot;  Read, Write, Append, Read &amp;amp; Write, Write &amp;amp; Read, Append &amp;amp; Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL)    Close int fclose(FILE *stream)  Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as you&amp;rsquo;re finished:  There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only)    Formatted I/O // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, .</description>
    </item>
    
  </channel>
</rss>