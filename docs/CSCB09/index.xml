<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSCB09 on &lt;✏️ /></title><link>https://navn-r.github.io/notes/CSCB09/</link><description>Recent content in CSCB09 on &lt;✏️ /></description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 25 Jul 2020 20:45:11 +0000</lastBuildDate><atom:link href="https://navn-r.github.io/notes/CSCB09/index.xml" rel="self" type="application/rss+xml"/><item><title>Week 1</title><link>https://navn-r.github.io/notes/CSCB09/Week-1/</link><pubDate>Wed, 20 May 2020 14:33:50 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-1/</guid><description>Week 1 # Processes # What happens when you run a program.
Has Input and Output ends:
stdin: Standard Input - eg. Keyboard input goes through stdin stdout: Standard Output - eg. Terminal output (printing to screen) eg.
Navinns-MacBook-Pro:~ home$ sort # OS connects keyboard to stdin Watermelon Apple Strawberry Mango ^D # &amp;#39;exit&amp;#39; keybind, OS connects screen to stdout Apple Mango Strawberry Watermelon Pipelining and Redirection # Routing outputs of one program to the input of another, and outputting to a file instead of the screen.</description></item><item><title>Week 2</title><link>https://navn-r.github.io/notes/CSCB09/Week-2/</link><pubDate>Tue, 26 May 2020 17:52:24 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-2/</guid><description>Week 2 # File Management # How we survived without File Explorer
Directory Tree # / ├── Applications ├── Library ├── System ├── *Users* ├── Volumes ├── bin ├── cores ├── *dev* ├── etc -&amp;gt; private/etc ├── *home* -&amp;gt; /System/Volumes/Data/home ├── opt ├── private ├── sbin ├── tmp -&amp;gt; private/tmp ├── *usr* └── var -&amp;gt; private/var Paths # Absolute Path: from root dir</description></item><item><title>Week 3</title><link>https://navn-r.github.io/notes/CSCB09/Week-3/</link><pubDate>Tue, 02 Jun 2020 17:42:22 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-3/</guid><description>Week 3 # Introduction to Shell # More features available from man sh
Simple Commands # 4 general cases of commands
Built in commands: cd, ls etc. User defined functions Aliases eg. alias pls=&amp;quot;sudo&amp;quot; Commands that refer to the program name eg. tr command runs the tr program Sequential List # Multi-line commands in a single line
$ cd projects ; sort file1 | uniq # runs cd then runs sort with pipe # equivalent to $ cd projects projects$ sort file1 | uniq Grouping: Explicit: {grep foo file1 ; ls ; } &amp;gt; file2 Exit Codes # 0 for success, non-0 for failure</description></item><item><title>Week 4</title><link>https://navn-r.github.io/notes/CSCB09/Week-4/</link><pubDate>Tue, 02 Jun 2020 19:14:38 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-4/</guid><description>Week 4 # Shell Scripting # Running Scripts # $ sh myscript Alternatively, in your myscript.sh file, do the following
#! /bin/sh chmod u+x myscript # sets &amp;#39;executable&amp;#39; flag on the file and run it with&amp;hellip;
$ ./myscript Positional Parameters # $ ./myscript foo bar baz # come after filename, spaced $#: Number of arguments (3) $n: Parameter name (n is the number) eg. $1 = &amp;quot;foo&amp;quot; $*: One string with all parameter names &amp;quot;foo bar baz&amp;quot; $@: Comma seperated strings for each parameter name &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; shift: Shifts Positional Parameters by 1 $# = 2 $1 = &amp;#34;bar&amp;#34; $2 = &amp;#34;baz&amp;#34; $* = &amp;#34;bar baz&amp;#34; # good for looping over parameters Example Script # #!</description></item><item><title>Week 5</title><link>https://navn-r.github.io/notes/CSCB09/Week-5/</link><pubDate>Wed, 10 Jun 2020 17:30:31 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-5/</guid><description>Week 5 # Programming in C # Memory Model # Array of bytes, &amp;ldquo;Addresses&amp;rdquo; are indexes Variables may occupy several consecutive bytes, its address refers to the first occupied byte &amp;ldquo;Pointer&amp;rdquo;: Variable/parameter that stores an address int i = 69; // Suppose i was occupying bytes 45 to 74 int *p = &amp;amp;i // 45 Memory Regions # Text: Stores code Pointers pointing to functions point here Global: Stores global variables Stack: Used for function calls Stores local variables Auto allocation and deallocation Heap: Manual allocation (malloc(), calloc()) and deallocation (free()) Used for dynamic data outside of functions Global Variables # Two types of varaibles int pubVar = 10; // top-level public global variable int f() { static int privVar = 1010; // function private global variable pubVar++; privVar++; .</description></item><item><title>Week 6</title><link>https://navn-r.github.io/notes/CSCB09/Week-6/</link><pubDate>Wed, 17 Jun 2020 00:06:17 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-6/</guid><description>Week 6 # Programming in C (cont.) # File I/O in C # Content can be accessed as a steam (seq. read/write) File functions work with FILE * FILE: Type rep. stream state, definition varies by platform, most likely a struct Open # FILE *fopen(const char *filename, const char *mode) Modes: &amp;quot;r&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;r+&amp;quot;, &amp;quot;w+&amp;quot;, &amp;quot;a+&amp;quot; Read, Write, Append, Read &amp;amp; Write, Write &amp;amp; Read, Append &amp;amp; Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL) Close # int fclose(FILE *stream) Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as you&amp;rsquo;re finished: There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only) Formatted I/O # // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, .</description></item><item><title>Week 7</title><link>https://navn-r.github.io/notes/CSCB09/Week-7/</link><pubDate>Wed, 08 Jul 2020 17:41:52 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-7/</guid><description>Week 7 # Programming in C (cont.) # Compiler and Linker Stages # myProgram.c $\to$ Compiler $\to$ Machine Code (myProgram.o) $\to$ Libraries + Linker $\to$ Executable
myProgram.o is the object code file Libraries: where methods from stdio.h/stdlib.h come from Linker: Merges object files and libraries into one executable gcc serves as a convenient linker frontend C Compiler Stages # The C compiler futher breaks down into:</description></item><item><title>Week 8</title><link>https://navn-r.github.io/notes/CSCB09/Week-8/</link><pubDate>Sat, 18 Jul 2020 20:09:18 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-8/</guid><description>Week 8 # File System with C # i-nodes # The file system has an array of &amp;lsquo;i-nodes&amp;rsquo;
Every file and directory is identified using an i-node
An i-node stores:
Type: Regular file, dir, link, device, socket, etc. Permissions The owning user and owning group (numerical ids) Size Timestamps (created, last modified) Which disk blocks are used Other metadata You can get most metadata by using the stat command</description></item><item><title>Week 9</title><link>https://navn-r.github.io/notes/CSCB09/Week-9/</link><pubDate>Sat, 25 Jul 2020 20:45:11 +0000</pubDate><guid>https://navn-r.github.io/notes/CSCB09/Week-9/</guid><description>Week 9 # Processes and Redirection # Launching a New Process # Clone the process pid_t fork(void); // child gets return value 0, parent gets child&amp;#39;s pid Both processes (child and parent) run the same code The child can switch to running another program execlp(path, arg0, arg1, ..., (char *)NULL); // &amp;#39;exec&amp;#39; family of system calls Things such as environment variables, pid, fd, current dir, etc.</description></item></channel></rss>