<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Week 6 Programming in C (cont.) File I/O in C  Content can be accessed as a steam (seq. read/write) File functions work with FILE *  FILE: Type rep. stream state, definition varies by platform, most likely a struct    Open FILE *fopen(const char *filename, const char *mode)  Modes: &quot;r&quot;, &quot;w&quot;, &quot;a&quot;, &quot;r&#43;&quot;, &quot;w&#43;&quot;, &quot;a&#43;&quot;  Read, Write, Append, Read &amp; Write, Write &amp; Read, Append &amp; Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL)    Close int fclose(FILE *stream)  Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as you&rsquo;re finished:  There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only)    Formatted I/O // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, .">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Week 6" />
<meta property="og:description" content="Week 6 Programming in C (cont.) File I/O in C  Content can be accessed as a steam (seq. read/write) File functions work with FILE *  FILE: Type rep. stream state, definition varies by platform, most likely a struct    Open FILE *fopen(const char *filename, const char *mode)  Modes: &quot;r&quot;, &quot;w&quot;, &quot;a&quot;, &quot;r&#43;&quot;, &quot;w&#43;&quot;, &quot;a&#43;&quot;  Read, Write, Append, Read &amp; Write, Write &amp; Read, Append &amp; Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL)    Close int fclose(FILE *stream)  Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as you&rsquo;re finished:  There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only)    Formatted I/O // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://navn-r.github.io/notes/CSCB09/Week-6/" />
<meta property="article:published_time" content="2020-06-17T00:06:17+00:00" />
<meta property="article:modified_time" content="2020-06-17T00:06:17+00:00" />

<title>Week 6</title>
<link rel="manifest" href="/notes/manifest.json">
<link rel="icon" href="/notes/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/notes/book.min.925429c68f754810964c935df53f0e8c7cd06367d0fb2f0a27dbe54ef9fbcc60.css" integrity="sha256-klQpxo91SBCWTJNd9T8OjHzQY2fQ&#43;y8KJ9vlTvn7zGA=">
<script defer src="/notes/en.search.min.ea1abb648a40f3063a851d304cc5d1c4989825e890e50a1b58598330ace786fa.js" integrity="sha256-6hq7ZIpA8wY6hR0wTMXRxJiYJeiQ5QobWFmDMKznhvo="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/notes"><span>&lt;✏️ /&gt;</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  

  



  
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/CSCA48/" class="">CSCA48</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/CSCA48/final-review/" class="">Final Review</a>
  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/CSCB09/" class="collapsed ">CSCB09</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/notes/CSCB09/Week-1/" class="">Week 1</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/CSCB09/Week-2/" class="">Week 2</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/CSCB09/Week-3/" class="">Week 3</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/CSCB09/Week-4/" class="">Week 4</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/CSCB09/Week-5/" class="">Week 5</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/notes/CSCB09/Week-6/" class="active">Week 6</a>
  

        </li>
      
    
  </ul>
  

        </li>
      
    
  </ul>
  











  
<ul>
  
  <li>
    <a href="https://github.com/navn-r/course-notes" target="_blank" rel="noopener">
        Notes Repo (Github)
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/notes/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Week 6</strong>

  <label for="toc-control">
    
    <img src="/notes/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#programming-in-c-cont">Programming in <code>C</code> (cont.)</a>
      <ul>
        <li><a href="#file-io-in-c">File I/O in <code>C</code></a></li>
        <li><a href="#open">Open</a></li>
        <li><a href="#close">Close</a></li>
        <li><a href="#formatted-io">Formatted I/O</a></li>
        <li><a href="#character-and-string-io">Character and String I/O</a></li>
        <li><a href="#arbitrary-data-io">Arbitrary Data I/O</a></li>
        <li><a href="#error-versus-end-of-stream-disambiguation">Error versus End-of-Stream Disambiguation</a></li>
        <li><a href="#error-information">Error Information</a></li>
        <li><a href="#buffering">Buffering</a></li>
        <li><a href="#buffer-operations">Buffer Operations</a></li>
        <li><a href="#default-buffering-of-stdin-stdout-stderr">Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></a></li>
        <li><a href="#seeking">Seeking</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="week-6">Week 6</h1>
<h2 id="programming-in-c-cont">Programming in <code>C</code> (cont.)</h2>
<h3 id="file-io-in-c">File I/O in <code>C</code></h3>
<ul>
<li>Content can be accessed as a steam (seq. read/write)</li>
<li>File functions work with <code>FILE *</code>
<ul>
<li><code>FILE</code>: Type rep. stream state, definition varies by platform, most likely a <code>struct</code></li>
</ul>
</li>
</ul>
<h3 id="open">Open</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">FILE <span style="color:#f92672">*</span>fopen(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>mode)
</code></pre></div><ul>
<li>Modes: <code>&quot;r&quot;, &quot;w&quot;, &quot;a&quot;, &quot;r+&quot;, &quot;w+&quot;, &quot;a+&quot;</code>
<ul>
<li>Read, Write, Append, Read &amp; Write, Write &amp; Read, Append &amp; Read</li>
<li>Appending and Writing to a file will create a new one if the file does not exist</li>
<li>Reading to a non-existent file will cause an error (returns <code>NULL</code>)</li>
</ul>
</li>
</ul>
<h3 id="close">Close</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> fclose(FILE <span style="color:#f92672">*</span>stream)
</code></pre></div><ul>
<li>Close stream when finished with the file</li>
<li>Returns <code>0</code> if success, <code>EOF</code> if error</li>
<li>Why should you close the file as soon as you&rsquo;re finished:
<ul>
<li>There is a limit on how many streams are open per process</li>
<li>Writing may be buffered until closing</li>
<li>No two process can open the same file (Windows only)</li>
</ul>
</li>
</ul>
<h3 id="formatted-io">Formatted I/O</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">// printf and scanf but for a given stream
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> fprintf(FILE <span style="color:#f92672">*</span>stream, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>format, ...) 
<span style="color:#66d9ef">int</span> fscanf(FILE <span style="color:#f92672">*</span>stream, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>format, ...)
</code></pre></div><ul>
<li><code>printf</code> is just <code>fprintf</code> but <code>stdout</code> is specified
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">scanf(format, args) <span style="color:#f92672">==</span> fscanf(stdin, format, args) <span style="color:#75715e">//same for scanf
</span></code></pre></div></li>
<li>You do not need to manually close <code>stdin, stdout, stderr</code> streams</li>
</ul>
<h3 id="character-and-string-io">Character and String I/O</h3>
<ul>
<li>One single character: returns <code>EOF</code> if error or not found
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> putchar(<span style="color:#66d9ef">int</span> c)  <span style="color:#75715e">/* stdout */</span>
<span style="color:#66d9ef">int</span> putc(<span style="color:#66d9ef">int</span> c, FILE <span style="color:#f92672">*</span>stream)
<span style="color:#66d9ef">int</span> getchar(<span style="color:#66d9ef">void</span>)    <span style="color:#75715e">/* stdin */</span>
<span style="color:#66d9ef">int</span> getc(FILE <span style="color:#f92672">*</span>stream)
</code></pre></div></li>
<li>String:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> fputs(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>string, FILE <span style="color:#f92672">*</span>stream)   <span style="color:#75715e">// does not put a newline at the end
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>fgets(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>dest, <span style="color:#66d9ef">int</span> n, FILE <span style="color:#f92672">*</span>stream)  <span style="color:#75715e">// Reads at most (n-1) chars or until (and including) newline
</span></code></pre></div></li>
</ul>
<h3 id="arbitrary-data-io">Arbitrary Data I/O</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">size_t fread(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dest, size_t s, size_t n, FILE <span style="color:#f92672">*</span>stream)
size_t fwrite(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data, size_t s, size_t n,FILE <span style="color:#f92672">*</span>stream)
</code></pre></div><ul>
<li>Reads/Writes <code>n</code> items, each of <code>s</code> bytes</li>
<li>Returns how many items have been read/written</li>
<li>Potential Use Cases:
<ul>
<li>A whole array</li>
<li><code>struct</code></li>
<li>Raw bytes (array of <code>unsigned char</code>)</li>
</ul>
</li>
</ul>
<h3 id="error-versus-end-of-stream-disambiguation">Error versus End-of-Stream Disambiguation</h3>
<ul>
<li><code>getc</code>, <code>scanf</code> return <code>EOF</code> on error</li>
<li><code>fgets</code> returns <code>NULL</code></li>
<li><code>fread</code> returns &lt; <code>n</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> feof(FILE <span style="color:#f92672">*</span>stream)      <span style="color:#75715e">// returns true if end-of-stream
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ferror(FILE <span style="color:#f92672">*</span>stream)    <span style="color:#75715e">// returns true if error
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> clearerr(FILE <span style="color:#f92672">*</span>stream) <span style="color:#75715e">// clears end-of-stream and error status
</span></code></pre></div><h3 id="error-information">Error Information</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;errno.h&gt;</span><span style="color:#75715e">
</span></code></pre></div><ul>
<li>Global variable stores error reason of most recent error
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> errno;
</code></pre></div></li>
<li>Many possible values:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ENOENT  <span style="color:#75715e">// File does not exist
</span><span style="color:#75715e"></span>EACCESS <span style="color:#75715e">// No permission
</span><span style="color:#75715e"></span>EDOM    <span style="color:#75715e">// sqrt(-3.0)
</span></code></pre></div></li>
<li>Usually, we just use <code>perror</code> to print the error message to stderr:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span> perror(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>prefix)
</code></pre></div></li>
</ul>
<h3 id="buffering">Buffering</h3>
<ul>
<li><code>C</code> delays file writing
<ul>
<li>Accumulates data in a buffer until it is large, then requests the kernel to write that chunk</li>
</ul>
</li>
<li>Also hastens reading
<ul>
<li>Requests kernel to read a large chunk into the buffer, then serves read requests from said buffer</li>
</ul>
</li>
</ul>
<h3 id="buffer-operations">Buffer Operations</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> fflush(FILE <span style="color:#f92672">*</span>stream) <span style="color:#75715e">// Returns 0 if success, EOF if error
</span></code></pre></div><ul>
<li>Writes the buffer for the output stream</li>
<li>Clears the buffer for the input stream</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> setvbuf(FILE <span style="color:#f92672">*</span>stream, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">int</span> mode, size_t n)
</code></pre></div><table>
<thead>
<tr>
<th align="center">mode</th>
<th align="center">meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>_IOFBF</code></td>
<td align="center">full buffering</td>
</tr>
<tr>
<td align="center"><code>_IOLBF</code></td>
<td align="center">line buffering</td>
</tr>
<tr>
<td align="center"><code>_IONBF</code></td>
<td align="center">no buffering</td>
</tr>
</tbody>
</table>
<h3 id="default-buffering-of-stdin-stdout-stderr">Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></h3>
<ul>
<li>
<p>If Terminal:</p>
<ul>
<li><code>stdin</code>: line buffer</li>
<li><code>stdout</code>: no buffer</li>
<li><code>stderr</code>: <strong><em>complicated</em></strong></li>
</ul>
</li>
<li>
<p>If in a file or pipelined:</p>
<ul>
<li><code>stdin</code>: full buffer</li>
<li><code>stdout</code>: no buffer</li>
<li><code>stderr</code>: full buffer</li>
</ul>
</li>
</ul>
<h3 id="seeking">Seeking</h3>
<ul>
<li>Ask current position:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span> ftell(FILE <span style="color:#f92672">*</span>stream) <span style="color:#75715e">// returns -1L if error
</span></code></pre></div></li>
<li>Seek:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> fseek(FILE <span style="color:#f92672">*</span>stream, <span style="color:#66d9ef">long</span> i, <span style="color:#66d9ef">int</span> origin) <span style="color:#75715e">// non-zero return if error
</span></code></pre></div><table>
<thead>
<tr>
<th align="center">origin</th>
<th align="center">go to <code>i</code> bytes from</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>SEEK_SET</code></td>
<td align="center">beginning</td>
</tr>
<tr>
<td align="center"><code>SEEK_END</code></td>
<td align="center">end</td>
</tr>
<tr>
<td align="center"><code>SEEK_CUR</code></td>
<td align="center">current position</td>
</tr>
</tbody>
</table>
</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#programming-in-c-cont">Programming in <code>C</code> (cont.)</a>
      <ul>
        <li><a href="#file-io-in-c">File I/O in <code>C</code></a></li>
        <li><a href="#open">Open</a></li>
        <li><a href="#close">Close</a></li>
        <li><a href="#formatted-io">Formatted I/O</a></li>
        <li><a href="#character-and-string-io">Character and String I/O</a></li>
        <li><a href="#arbitrary-data-io">Arbitrary Data I/O</a></li>
        <li><a href="#error-versus-end-of-stream-disambiguation">Error versus End-of-Stream Disambiguation</a></li>
        <li><a href="#error-information">Error Information</a></li>
        <li><a href="#buffering">Buffering</a></li>
        <li><a href="#buffer-operations">Buffer Operations</a></li>
        <li><a href="#default-buffering-of-stdin-stdout-stderr">Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></a></li>
        <li><a href="#seeking">Seeking</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  <script defer src="/notes/katex/auto-render.min.js" onload="renderMathInElement(document.body, {
    delimiters: [
      { left: '$$', right: '$$', display: true },
      { left: '$', right: '$', display: false },
    ],
  });"></script>
</body>

</html>












