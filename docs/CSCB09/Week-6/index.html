<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Week 6 Programming in C (cont.) File I/O in C  Content can be accessed as a steam (seq. read/write) File functions work with FILE *  FILE: Type rep. stream state, definition varies by platform, most likely a struct    Open FILE *fopen(const char *filename, const char *mode)  Modes: &#34;r&#34;, &#34;w&#34;, &#34;a&#34;, &#34;r+&#34;, &#34;w+&#34;, &#34;a+&#34;  Read, Write, Append, Read & Write, Write & Read, Append & Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL)    Close int fclose(FILE *stream)  Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as you&rsquo;re finished:  There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only)    Formatted I/O // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, ."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Week 6"><meta property="og:description" content="Week 6 Programming in C (cont.) File I/O in C  Content can be accessed as a steam (seq. read/write) File functions work with FILE *  FILE: Type rep. stream state, definition varies by platform, most likely a struct    Open FILE *fopen(const char *filename, const char *mode)  Modes: &#34;r&#34;, &#34;w&#34;, &#34;a&#34;, &#34;r+&#34;, &#34;w+&#34;, &#34;a+&#34;  Read, Write, Append, Read & Write, Write & Read, Append & Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL)    Close int fclose(FILE *stream)  Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as you&rsquo;re finished:  There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only)    Formatted I/O // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, ."><meta property="og:type" content="article"><meta property="og:url" content="https://navn-r.github.io/notes/CSCB09/Week-6/"><meta property="article:published_time" content="2020-06-17T00:06:17+00:00"><meta property="article:modified_time" content="2020-06-17T00:06:17+00:00"><title>Week 6 - CSCB09</title><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@420&display=swap" rel=stylesheet><link rel=manifest href=/notes/manifest.json><link rel=icon href=/notes/favicon.png type=image/x-icon><link rel=stylesheet href=/notes/book.min.05ebbe252cb4c7ce23b9ebf0d8510e7f73238222a89b74e34ff88517b5a11fcb.css integrity="sha256-Beu+JSy0x84juevw2FEOf3MjgiKom3TjT/iFF7WhH8s="><script defer src=/notes/en.search.min.7c5999991b1b0240f5ab19f974795fe6ef2bac7f6e873e0885129ef0328e10eb.js integrity="sha256-fFmZmRsbAkD1qxn5dHlf5u8rrH9uhz4IhRKe8DKOEOs="></script></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/notes><span>&lt;✏️ /></span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/notes/CSCA48/>CSCA48</a><ul><li><a href=/notes/CSCA48/final-review/>Final Review</a></li></ul></li><li><a href=/notes/CSCB09/ class=collapsed>CSCB09</a><ul><li><a href=/notes/CSCB09/Week-1/>Week 1</a></li><li><a href=/notes/CSCB09/Week-2/>Week 2</a></li><li><a href=/notes/CSCB09/Week-3/>Week 3</a></li><li><a href=/notes/CSCB09/Week-4/>Week 4</a></li><li><a href=/notes/CSCB09/Week-5/>Week 5</a></li><li><a href=/notes/CSCB09/Week-6/ class=active>Week 6</a></li><li><a href=/notes/CSCB09/Week-7/>Week 7</a></li></ul></li></ul><ul><li><a href=https://github.com/navn-r/course-notes target=_blank rel=noopener>Notes Repo (Github)</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/notes/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Week 6</strong>
<label for=toc-control><img src=/notes/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><input type=checkbox class=hidden id=toc-control><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#programming-in-c-cont>Programming in <code>C</code> (cont.)</a><ul><li><a href=#file-io-in-c>File I/O in <code>C</code></a></li><li><a href=#open>Open</a></li><li><a href=#close>Close</a></li><li><a href=#formatted-io>Formatted I/O</a></li><li><a href=#character-and-string-io>Character and String I/O</a></li><li><a href=#arbitrary-data-io>Arbitrary Data I/O</a></li><li><a href=#error-versus-end-of-stream-disambiguation>Error versus End-of-Stream Disambiguation</a></li><li><a href=#error-information>Error Information</a></li><li><a href=#buffering>Buffering</a></li><li><a href=#buffer-operations>Buffer Operations</a></li><li><a href=#default-buffering-of-stdin-stdout-stderr>Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></a></li><li><a href=#seeking>Seeking</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=week-6>Week 6</h1><h2 id=programming-in-c-cont>Programming in <code>C</code> (cont.)</h2><h3 id=file-io-in-c>File I/O in <code>C</code></h3><ul><li>Content can be accessed as a steam (seq. read/write)</li><li>File functions work with <code>FILE *</code><ul><li><code>FILE</code>: Type rep. stream state, definition varies by platform, most likely a <code>struct</code></li></ul></li></ul><h3 id=open>Open</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>FILE <span style=color:#f92672>*</span>fopen(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>mode)
</code></pre></div><ul><li>Modes: <code>"r", "w", "a", "r+", "w+", "a+"</code><ul><li>Read, Write, Append, Read & Write, Write & Read, Append & Read</li><li>Appending and Writing to a file will create a new one if the file does not exist</li><li>Reading to a non-existent file will cause an error (returns <code>NULL</code>)</li></ul></li></ul><h3 id=close>Close</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> fclose(FILE <span style=color:#f92672>*</span>stream)
</code></pre></div><ul><li>Close stream when finished with the file</li><li>Returns <code>0</code> if success, <code>EOF</code> if error</li><li>Why should you close the file as soon as you&rsquo;re finished:<ul><li>There is a limit on how many streams are open per process</li><li>Writing may be buffered until closing</li><li>No two process can open the same file (Windows only)</li></ul></li></ul><h3 id=formatted-io>Formatted I/O</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>// printf and scanf but for a given stream
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> fprintf(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...) 
<span style=color:#66d9ef>int</span> fscanf(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...)
</code></pre></div><ul><li><code>printf</code> is just <code>fprintf</code> but <code>stdout</code> is specified<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>scanf(format, args) <span style=color:#f92672>==</span> fscanf(stdin, format, args) <span style=color:#75715e>//same for scanf
</span></code></pre></div></li><li>You do not need to manually close <code>stdin, stdout, stderr</code> streams</li></ul><h3 id=character-and-string-io>Character and String I/O</h3><ul><li>One single character: returns <code>EOF</code> if error or not found<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> putchar(<span style=color:#66d9ef>int</span> c)  <span style=color:#75715e>/* stdout */</span>
<span style=color:#66d9ef>int</span> putc(<span style=color:#66d9ef>int</span> c, FILE <span style=color:#f92672>*</span>stream)
<span style=color:#66d9ef>int</span> getchar(<span style=color:#66d9ef>void</span>)    <span style=color:#75715e>/* stdin */</span>
<span style=color:#66d9ef>int</span> getc(FILE <span style=color:#f92672>*</span>stream)
</code></pre></div></li><li>String:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> fputs(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>string, FILE <span style=color:#f92672>*</span>stream)   <span style=color:#75715e>// does not put a newline at the end
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fgets(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>dest, <span style=color:#66d9ef>int</span> n, FILE <span style=color:#f92672>*</span>stream)  <span style=color:#75715e>// Reads at most (n-1) chars or until (and including) newline
</span></code></pre></div></li></ul><h3 id=arbitrary-data-io>Arbitrary Data I/O</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>size_t fread(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, size_t s, size_t n, FILE <span style=color:#f92672>*</span>stream)
size_t fwrite(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data, size_t s, size_t n,FILE <span style=color:#f92672>*</span>stream)
</code></pre></div><ul><li>Reads/Writes <code>n</code> items, each of <code>s</code> bytes</li><li>Returns how many items have been read/written</li><li>Potential Use Cases:<ul><li>A whole array</li><li><code>struct</code></li><li>Raw bytes (array of <code>unsigned char</code>)</li></ul></li></ul><h3 id=error-versus-end-of-stream-disambiguation>Error versus End-of-Stream Disambiguation</h3><ul><li><code>getc</code>, <code>scanf</code> return <code>EOF</code> on error</li><li><code>fgets</code> returns <code>NULL</code></li><li><code>fread</code> returns &lt; <code>n</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> feof(FILE <span style=color:#f92672>*</span>stream)      <span style=color:#75715e>// returns true if end-of-stream
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ferror(FILE <span style=color:#f92672>*</span>stream)    <span style=color:#75715e>// returns true if error
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> clearerr(FILE <span style=color:#f92672>*</span>stream) <span style=color:#75715e>// clears end-of-stream and error status
</span></code></pre></div><h3 id=error-information>Error Information</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></code></pre></div><ul><li>Global variable stores error reason of most recent error<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> errno;
</code></pre></div></li><li>Many possible values:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>ENOENT  <span style=color:#75715e>// File does not exist
</span><span style=color:#75715e></span>EACCESS <span style=color:#75715e>// No permission
</span><span style=color:#75715e></span>EDOM    <span style=color:#75715e>// sqrt(-3.0)
</span></code></pre></div></li><li>Usually, we just use <code>perror</code> to print the error message to stderr:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>void</span> perror(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>prefix)
</code></pre></div></li></ul><h3 id=buffering>Buffering</h3><ul><li><code>C</code> delays file writing<ul><li>Accumulates data in a buffer until it is large, then requests the kernel to write that chunk</li></ul></li><li>Also hastens reading<ul><li>Requests kernel to read a large chunk into the buffer, then serves read requests from said buffer</li></ul></li></ul><h3 id=buffer-operations>Buffer Operations</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> fflush(FILE <span style=color:#f92672>*</span>stream) <span style=color:#75715e>// Returns 0 if success, EOF if error
</span></code></pre></div><ul><li>Writes the buffer for the output stream</li><li>Clears the buffer for the input stream</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> setvbuf(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> mode, size_t n)
</code></pre></div><table><thead><tr><th align=center>mode</th><th align=center>meaning</th></tr></thead><tbody><tr><td align=center><code>_IOFBF</code></td><td align=center>full buffering</td></tr><tr><td align=center><code>_IOLBF</code></td><td align=center>line buffering</td></tr><tr><td align=center><code>_IONBF</code></td><td align=center>no buffering</td></tr></tbody></table><h3 id=default-buffering-of-stdin-stdout-stderr>Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></h3><ul><li><p>If Terminal:</p><ul><li><code>stdin</code>: line buffer</li><li><code>stdout</code>: no buffer</li><li><code>stderr</code>: <strong><em>complicated</em></strong></li></ul></li><li><p>If in a file or pipelined:</p><ul><li><code>stdin</code>: full buffer</li><li><code>stdout</code>: no buffer</li><li><code>stderr</code>: full buffer</li></ul></li></ul><h3 id=seeking>Seeking</h3><ul><li>Ask current position:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> ftell(FILE <span style=color:#f92672>*</span>stream) <span style=color:#75715e>// returns -1L if error
</span></code></pre></div></li><li>Seek:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> fseek(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>long</span> i, <span style=color:#66d9ef>int</span> origin) <span style=color:#75715e>// non-zero return if error
</span></code></pre></div><table><thead><tr><th align=center>origin</th><th align=center>go to <code>i</code> bytes from</th></tr></thead><tbody><tr><td align=center><code>SEEK_SET</code></td><td align=center>beginning</td></tr><tr><td align=center><code>SEEK_END</code></td><td align=center>end</td></tr><tr><td align=center><code>SEEK_CUR</code></td><td align=center>current position</td></tr></tbody></table></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#programming-in-c-cont>Programming in <code>C</code> (cont.)</a><ul><li><a href=#file-io-in-c>File I/O in <code>C</code></a></li><li><a href=#open>Open</a></li><li><a href=#close>Close</a></li><li><a href=#formatted-io>Formatted I/O</a></li><li><a href=#character-and-string-io>Character and String I/O</a></li><li><a href=#arbitrary-data-io>Arbitrary Data I/O</a></li><li><a href=#error-versus-end-of-stream-disambiguation>Error versus End-of-Stream Disambiguation</a></li><li><a href=#error-information>Error Information</a></li><li><a href=#buffering>Buffering</a></li><li><a href=#buffer-operations>Buffer Operations</a></li><li><a href=#default-buffering-of-stdin-stdout-stderr>Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></a></li><li><a href=#seeking>Seeking</a></li></ul></li></ul></nav></aside></main><script defer src=/notes/katex/auto-render.min.js onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},],});"></script></body></html>