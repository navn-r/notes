<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Week 6
  #


  Programming in C (cont.)
  #


  File I/O in C
  #


Content can be accessed as a steam (seq. read/write)
File functions work with FILE *

FILE: Type rep. stream state, definition varies by platform, most likely a struct




  Open
  #

FILE *fopen(const char *filename, const char *mode)

Modes: "r", "w", "a", "r+", "w+", "a+"

Read, Write, Append, Read & Write, Write & Read, Append & Read
Appending and Writing to a file will create a new one if the file does not exist
Reading to a non-existent file will cause an error (returns NULL)




  Close
  #

int fclose(FILE *stream)

Close stream when finished with the file
Returns 0 if success, EOF if error
Why should you close the file as soon as you&rsquo;re finished:

There is a limit on how many streams are open per process
Writing may be buffered until closing
No two process can open the same file (Windows only)




  Formatted I/O
  #

// printf and scanf but for a given stream
int fprintf(FILE *stream, const char *format, ...) 
int fscanf(FILE *stream, const char *format, ...)

printf is just fprintf but stdout is specified
scanf(format, args) == fscanf(stdin, format, args) //same for scanf

You do not need to manually close stdin, stdout, stderr streams


  Character and String I/O
  #


One single character: returns EOF if error or not found
int putchar(int c)  /* stdout */
int putc(int c, FILE *stream)
int getchar(void)    /* stdin */
int getc(FILE *stream)

String:
int fputs(const char *string, FILE *stream)   // does not put a newline at the end
char *fgets(char *dest, int n, FILE *stream)  // Reads at most (n-1) chars or until (and including) newline



  Arbitrary Data I/O
  #

size_t fread(void *dest, size_t s, size_t n, FILE *stream)
size_t fwrite(const void *data, size_t s, size_t n,FILE *stream)

Reads/Writes n items, each of s bytes
Returns how many items have been read/written
Potential Use Cases:

A whole array
struct
Raw bytes (array of unsigned char)




  Error versus End-of-Stream Disambiguation
  #


getc, scanf return EOF on error
fgets returns NULL
fread returns < n

int feof(FILE *stream)      // returns true if end-of-stream
int ferror(FILE *stream)    // returns true if error
void clearerr(FILE *stream) // clears end-of-stream and error status

  Error Information
  #

#include <errno.h>

Global variable stores error reason of most recent error
int errno;

Many possible values:
ENOENT  // File does not exist
EACCESS // No permission
EDOM    // sqrt(-3.0)

Usually, we just use perror to print the error message to stderr:
void perror(const char *prefix)



  Buffering
  #


C delays file writing

Accumulates data in a buffer until it is large, then requests the kernel to write that chunk


Also hastens reading

Requests kernel to read a large chunk into the buffer, then serves read requests from said buffer




  Buffer Operations
  #

int fflush(FILE *stream) // Returns 0 if success, EOF if error

Writes the buffer for the output stream
Clears the buffer for the input stream

int setvbuf(FILE *stream, char *buf, int mode, size_t n)

  
      
          mode
          meaning
      
  
  
      
          _IOFBF
          full buffering
      
      
          _IOLBF
          line buffering
      
      
          _IONBF
          no buffering
      
  


  Default Buffering of stdin, stdout, stderr
  #



If Terminal:'><meta name=theme-color content="#FFFFFF"><meta property="og:url" content="https://navn.me/notes/CSCB09/Week-6/"><meta property="og:site_name" content="Notes"><meta property="og:title" content="Week 6"><meta property="og:description" content='Week 6 # Programming in C (cont.) # File I/O in C # Content can be accessed as a steam (seq. read/write) File functions work with FILE * FILE: Type rep. stream state, definition varies by platform, most likely a struct Open # FILE *fopen(const char *filename, const char *mode) Modes: "r", "w", "a", "r+", "w+", "a+" Read, Write, Append, Read & Write, Write & Read, Append & Read Appending and Writing to a file will create a new one if the file does not exist Reading to a non-existent file will cause an error (returns NULL) Close # int fclose(FILE *stream) Close stream when finished with the file Returns 0 if success, EOF if error Why should you close the file as soon as youâ€™re finished: There is a limit on how many streams are open per process Writing may be buffered until closing No two process can open the same file (Windows only) Formatted I/O # // printf and scanf but for a given stream int fprintf(FILE *stream, const char *format, ...) int fscanf(FILE *stream, const char *format, ...) printf is just fprintf but stdout is specified scanf(format, args) == fscanf(stdin, format, args) //same for scanf You do not need to manually close stdin, stdout, stderr streams Character and String I/O # One single character: returns EOF if error or not found int putchar(int c) /* stdout */ int putc(int c, FILE *stream) int getchar(void) /* stdin */ int getc(FILE *stream) String: int fputs(const char *string, FILE *stream) // does not put a newline at the end char *fgets(char *dest, int n, FILE *stream) // Reads at most (n-1) chars or until (and including) newline Arbitrary Data I/O # size_t fread(void *dest, size_t s, size_t n, FILE *stream) size_t fwrite(const void *data, size_t s, size_t n,FILE *stream) Reads/Writes n items, each of s bytes Returns how many items have been read/written Potential Use Cases: A whole array struct Raw bytes (array of unsigned char) Error versus End-of-Stream Disambiguation # getc, scanf return EOF on error fgets returns NULL fread returns < n int feof(FILE *stream) // returns true if end-of-stream int ferror(FILE *stream) // returns true if error void clearerr(FILE *stream) // clears end-of-stream and error status Error Information # #include <errno.h> Global variable stores error reason of most recent error int errno; Many possible values: ENOENT // File does not exist EACCESS // No permission EDOM // sqrt(-3.0) Usually, we just use perror to print the error message to stderr: void perror(const char *prefix) Buffering # C delays file writing Accumulates data in a buffer until it is large, then requests the kernel to write that chunk Also hastens reading Requests kernel to read a large chunk into the buffer, then serves read requests from said buffer Buffer Operations # int fflush(FILE *stream) // Returns 0 if success, EOF if error Writes the buffer for the output stream Clears the buffer for the input stream int setvbuf(FILE *stream, char *buf, int mode, size_t n) mode meaning _IOFBF full buffering _IOLBF line buffering _IONBF no buffering Default Buffering of stdin, stdout, stderr # If Terminal:'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="cscb09"><meta property="article:published_time" content="2020-06-17T00:06:17+00:00"><meta property="article:modified_time" content="2020-06-17T00:06:17+00:00"><title>Week 6 - cscb09</title><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@420&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap" rel=stylesheet><link rel=manifest href=/notes/manifest.json><link rel=icon href=/notes/favicon.png type=image/x-icon><link rel=stylesheet href=/notes/book.min.630665e30ad00e934c909605146e9dd098208e9d170377271366498a917ed656.css integrity="sha256-YwZl4wrQDpNMkJYFFG6d0Jggjp0XA3cnE2ZJipF+1lY=" crossorigin=anonymous><script defer src=/notes/fuse.min.js></script><script defer src=/notes/en.search.min.02bfedc392966cdb6b729f481fd3adeee1ab6b30cc1b5dae9e8d1762d00f1a79.js integrity="sha256-Ar/tw5KWbNtrcp9IH9Ot7uGrazDMG12uno0XYtAPGnk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/notes/><img src=/notes/logo.svg alt=Logo class=book-icon><span>Notes</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-eecd534dc11f03d48ad2e7d87541675c class=toggle>
<label for=section-eecd534dc11f03d48ad2e7d87541675c class=flex><a href=/notes/CSCA48/ class=flex-auto>CSCA48</a></label><ul><li><a href=/notes/CSCA48/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-0ded7730b14c7695e8d77042e371164e class=toggle checked>
<label for=section-0ded7730b14c7695e8d77042e371164e class=flex><a href=/notes/CSCB09/ class=flex-auto>CSCB09</a></label><ul><li><a href=/notes/CSCB09/Week-1/>Week 1</a></li><li><a href=/notes/CSCB09/Week-2/>Week 2</a></li><li><a href=/notes/CSCB09/Week-3/>Week 3</a></li><li><a href=/notes/CSCB09/Week-4/>Week 4</a></li><li><a href=/notes/CSCB09/Week-5/>Week 5</a></li><li><a href=/notes/CSCB09/Week-6/ class=active>Week 6</a></li><li><a href=/notes/CSCB09/Week-7/>Week 7</a></li><li><a href=/notes/CSCB09/Week-8/>Week 8</a></li><li><a href=/notes/CSCB09/Week-9/>Week 9</a></li><li><a href=/notes/CSCB09/Week-10/>Week 10</a></li><li><a href=/notes/CSCB09/Week-11/>Week 11</a></li></ul></li><li><input type=checkbox id=section-83878c136730e7fb5606682d9ae45dfe class=toggle>
<label for=section-83878c136730e7fb5606682d9ae45dfe class=flex><a href=/notes/CSCC01/ class=flex-auto>CSCC01</a></label><ul><li><a href=/notes/CSCC01/final-review/>Final Review</a></li><li><a href=/notes/CSCC01/ci-cd/>Guest Lecture - CI/CD</a></li></ul></li><li><input type=checkbox id=section-d311fefcc209fce910ef2e1c0a1fd052 class=toggle>
<label for=section-d311fefcc209fce910ef2e1c0a1fd052 class=flex><a href=/notes/CSCC24/ class=flex-auto>CSCC24</a></label><ul><li><a href=/notes/CSCC24/Week-1/>Week 1</a></li><li><a href=/notes/CSCC24/Week-2/>Week 2</a></li><li><a href=/notes/CSCC24/Week-3/>Week 3</a></li><li><a href=/notes/CSCC24/Week-4/>Week 4</a></li><li><a href=/notes/CSCC24/Week-5/>Week 5</a></li><li><a href=/notes/CSCC24/Week-6/>Week 6</a></li><li><a href=/notes/CSCC24/Week-7/>Week 7</a></li><li><a href=/notes/CSCC24/Week-8/>Week 8</a></li><li><a href=/notes/CSCC24/Week-9/>Week 9</a></li><li><a href=/notes/CSCC24/Week-10/>Week 10</a></li></ul></li><li><input type=checkbox id=section-a71f1103b1bf523367e6db76cc50f6a6 class=toggle>
<label for=section-a71f1103b1bf523367e6db76cc50f6a6 class=flex><a href=/notes/CSCC43/ class=flex-auto>CSCC43</a></label><ul><li><a href=/notes/CSCC43/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-45f38cf9287c788a19429c70038c2def class=toggle>
<label for=section-45f38cf9287c788a19429c70038c2def class=flex><a href=/notes/CSCC69/ class=flex-auto>CSCC69</a></label><ul><li><a href=/notes/CSCC69/final-review/>Final Review</a></li></ul></li></ul><ul><li><a href=https://github.com/navn-r/notes target=_blank rel=noopener>Github Repo</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/notes/svg/menu.svg class=book-icon alt=Menu></label><h3>Week 6</h3><label for=toc-control><img src=/notes/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#programming-in-c-cont>Programming in <code>C</code> (cont.)</a><ul><li><a href=#file-io-in-c>File I/O in <code>C</code></a></li><li><a href=#open>Open</a></li><li><a href=#close>Close</a></li><li><a href=#formatted-io>Formatted I/O</a></li><li><a href=#character-and-string-io>Character and String I/O</a></li><li><a href=#arbitrary-data-io>Arbitrary Data I/O</a></li><li><a href=#error-versus-end-of-stream-disambiguation>Error versus End-of-Stream Disambiguation</a></li><li><a href=#error-information>Error Information</a></li><li><a href=#buffering>Buffering</a></li><li><a href=#buffer-operations>Buffer Operations</a></li><li><a href=#default-buffering-of-stdin-stdout-stderr>Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></a></li><li><a href=#seeking>Seeking</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=week-6>Week 6
<a class=anchor href=#week-6>#</a></h1><h2 id=programming-in-c-cont>Programming in <code>C</code> (cont.)
<a class=anchor href=#programming-in-c-cont>#</a></h2><h3 id=file-io-in-c>File I/O in <code>C</code>
<a class=anchor href=#file-io-in-c>#</a></h3><ul><li>Content can be accessed as a steam (seq. read/write)</li><li>File functions work with <code>FILE *</code><ul><li><code>FILE</code>: Type rep. stream state, definition varies by platform, most likely a <code>struct</code></li></ul></li></ul><h3 id=open>Open
<a class=anchor href=#open>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>FILE <span style=color:#f92672>*</span><span style=color:#a6e22e>fopen</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>mode)
</span></span></code></pre></div><ul><li>Modes: <code>"r", "w", "a", "r+", "w+", "a+"</code><ul><li>Read, Write, Append, Read & Write, Write & Read, Append & Read</li><li>Appending and Writing to a file will create a new one if the file does not exist</li><li>Reading to a non-existent file will cause an error (returns <code>NULL</code>)</li></ul></li></ul><h3 id=close>Close
<a class=anchor href=#close>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fclose</span>(FILE <span style=color:#f92672>*</span>stream)
</span></span></code></pre></div><ul><li>Close stream when finished with the file</li><li>Returns <code>0</code> if success, <code>EOF</code> if error</li><li>Why should you close the file as soon as you&rsquo;re finished:<ul><li>There is a limit on how many streams are open per process</li><li>Writing may be buffered until closing</li><li>No two process can open the same file (Windows only)</li></ul></li></ul><h3 id=formatted-io>Formatted I/O
<a class=anchor href=#formatted-io>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// printf and scanf but for a given stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fprintf</span>(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fscanf</span>(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...)
</span></span></code></pre></div><ul><li><code>printf</code> is just <code>fprintf</code> but <code>stdout</code> is specified<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(format, args) <span style=color:#f92672>==</span> <span style=color:#a6e22e>fscanf</span>(stdin, format, args) <span style=color:#75715e>//same for scanf
</span></span></span></code></pre></div></li><li>You do not need to manually close <code>stdin, stdout, stderr</code> streams</li></ul><h3 id=character-and-string-io>Character and String I/O
<a class=anchor href=#character-and-string-io>#</a></h3><ul><li>One single character: returns <code>EOF</code> if error or not found<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>putchar</span>(<span style=color:#66d9ef>int</span> c)  <span style=color:#75715e>/* stdout */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>putc</span>(<span style=color:#66d9ef>int</span> c, FILE <span style=color:#f92672>*</span>stream)
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getchar</span>(<span style=color:#66d9ef>void</span>)    <span style=color:#75715e>/* stdin */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getc</span>(FILE <span style=color:#f92672>*</span>stream)
</span></span></code></pre></div></li><li>String:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fputs</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>string, FILE <span style=color:#f92672>*</span>stream)   <span style=color:#75715e>// does not put a newline at the end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>fgets</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>dest, <span style=color:#66d9ef>int</span> n, FILE <span style=color:#f92672>*</span>stream)  <span style=color:#75715e>// Reads at most (n-1) chars or until (and including) newline
</span></span></span></code></pre></div></li></ul><h3 id=arbitrary-data-io>Arbitrary Data I/O
<a class=anchor href=#arbitrary-data-io>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>size_t</span> <span style=color:#a6e22e>fread</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, <span style=color:#66d9ef>size_t</span> s, <span style=color:#66d9ef>size_t</span> n, FILE <span style=color:#f92672>*</span>stream)
</span></span><span style=display:flex><span><span style=color:#66d9ef>size_t</span> <span style=color:#a6e22e>fwrite</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data, <span style=color:#66d9ef>size_t</span> s, <span style=color:#66d9ef>size_t</span> n,FILE <span style=color:#f92672>*</span>stream)
</span></span></code></pre></div><ul><li>Reads/Writes <code>n</code> items, each of <code>s</code> bytes</li><li>Returns how many items have been read/written</li><li>Potential Use Cases:<ul><li>A whole array</li><li><code>struct</code></li><li>Raw bytes (array of <code>unsigned char</code>)</li></ul></li></ul><h3 id=error-versus-end-of-stream-disambiguation>Error versus End-of-Stream Disambiguation
<a class=anchor href=#error-versus-end-of-stream-disambiguation>#</a></h3><ul><li><code>getc</code>, <code>scanf</code> return <code>EOF</code> on error</li><li><code>fgets</code> returns <code>NULL</code></li><li><code>fread</code> returns &lt; <code>n</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>feof</span>(FILE <span style=color:#f92672>*</span>stream)      <span style=color:#75715e>// returns true if end-of-stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ferror</span>(FILE <span style=color:#f92672>*</span>stream)    <span style=color:#75715e>// returns true if error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clearerr</span>(FILE <span style=color:#f92672>*</span>stream) <span style=color:#75715e>// clears end-of-stream and error status
</span></span></span></code></pre></div><h3 id=error-information>Error Information
<a class=anchor href=#error-information>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span></code></pre></div><ul><li>Global variable stores error reason of most recent error<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> errno;
</span></span></code></pre></div></li><li>Many possible values:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>ENOENT  <span style=color:#75715e>// File does not exist
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>EACCESS <span style=color:#75715e>// No permission
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>EDOM    <span style=color:#75715e>// sqrt(-3.0)
</span></span></span></code></pre></div></li><li>Usually, we just use <code>perror</code> to print the error message to stderr:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>perror</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>prefix)
</span></span></code></pre></div></li></ul><h3 id=buffering>Buffering
<a class=anchor href=#buffering>#</a></h3><ul><li><code>C</code> delays file writing<ul><li>Accumulates data in a buffer until it is large, then requests the kernel to write that chunk</li></ul></li><li>Also hastens reading<ul><li>Requests kernel to read a large chunk into the buffer, then serves read requests from said buffer</li></ul></li></ul><h3 id=buffer-operations>Buffer Operations
<a class=anchor href=#buffer-operations>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fflush</span>(FILE <span style=color:#f92672>*</span>stream) <span style=color:#75715e>// Returns 0 if success, EOF if error
</span></span></span></code></pre></div><ul><li>Writes the buffer for the output stream</li><li>Clears the buffer for the input stream</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>setvbuf</span>(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> mode, <span style=color:#66d9ef>size_t</span> n)
</span></span></code></pre></div><table><thead><tr><th style=text-align:center>mode</th><th style=text-align:center>meaning</th></tr></thead><tbody><tr><td style=text-align:center><code>_IOFBF</code></td><td style=text-align:center>full buffering</td></tr><tr><td style=text-align:center><code>_IOLBF</code></td><td style=text-align:center>line buffering</td></tr><tr><td style=text-align:center><code>_IONBF</code></td><td style=text-align:center>no buffering</td></tr></tbody></table><h3 id=default-buffering-of-stdin-stdout-stderr>Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code>
<a class=anchor href=#default-buffering-of-stdin-stdout-stderr>#</a></h3><ul><li><p>If Terminal:</p><ul><li><code>stdin</code>: line buffer</li><li><code>stdout</code>: no buffer</li><li><code>stderr</code>: <strong><em>complicated</em></strong></li></ul></li><li><p>If in a file or pipelined:</p><ul><li><code>stdin</code>: full buffer</li><li><code>stdout</code>: no buffer</li><li><code>stderr</code>: full buffer</li></ul></li></ul><h3 id=seeking>Seeking
<a class=anchor href=#seeking>#</a></h3><ul><li>Ask current position:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ftell</span>(FILE <span style=color:#f92672>*</span>stream) <span style=color:#75715e>// returns -1L if error
</span></span></span></code></pre></div></li><li>Seek:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fseek</span>(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>long</span> i, <span style=color:#66d9ef>int</span> origin) <span style=color:#75715e>// non-zero return if error
</span></span></span></code></pre></div><table><thead><tr><th style=text-align:center>origin</th><th style=text-align:center>go to <code>i</code> bytes from</th></tr></thead><tbody><tr><td style=text-align:center><code>SEEK_SET</code></td><td style=text-align:center>beginning</td></tr><tr><td style=text-align:center><code>SEEK_END</code></td><td style=text-align:center>end</td></tr><tr><td style=text-align:center><code>SEEK_CUR</code></td><td style=text-align:center>current position</td></tr></tbody></table></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#programming-in-c-cont>Programming in <code>C</code> (cont.)</a><ul><li><a href=#file-io-in-c>File I/O in <code>C</code></a></li><li><a href=#open>Open</a></li><li><a href=#close>Close</a></li><li><a href=#formatted-io>Formatted I/O</a></li><li><a href=#character-and-string-io>Character and String I/O</a></li><li><a href=#arbitrary-data-io>Arbitrary Data I/O</a></li><li><a href=#error-versus-end-of-stream-disambiguation>Error versus End-of-Stream Disambiguation</a></li><li><a href=#error-information>Error Information</a></li><li><a href=#buffering>Buffering</a></li><li><a href=#buffer-operations>Buffer Operations</a></li><li><a href=#default-buffering-of-stdin-stdout-stderr>Default Buffering of <code>stdin</code>, <code>stdout</code>, <code>stderr</code></a></li><li><a href=#seeking>Seeking</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=/notes/katex/katex.min.css><script defer src=/notes/katex/katex.min.js></script><script defer src=/notes/katex/auto-render.min.js onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script></body></html>